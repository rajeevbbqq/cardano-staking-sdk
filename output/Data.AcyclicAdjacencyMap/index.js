// Generated by purs version 0.14.5
"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Category = require("../Control.Category/index.js");
var Control_Monad_Cont_Class = require("../Control.Monad.Cont.Class/index.js");
var Control_Monad_Cont_Trans = require("../Control.Monad.Cont.Trans/index.js");
var Control_Monad_State_Class = require("../Control.Monad.State.Class/index.js");
var Control_Monad_State_Trans = require("../Control.Monad.State.Trans/index.js");
var Data_AdjacencyMap = require("../Data.AdjacencyMap/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Map_Internal = require("../Data.Map.Internal/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Newtype = require("../Data.Newtype/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ordering = require("../Data.Ordering/index.js");
var Data_Set = require("../Data.Set/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Unfoldable = require("../Data.Unfoldable/index.js");
var Effect_Exception_Unsafe = require("../Effect.Exception.Unsafe/index.js");
var Entered = (function () {
    function Entered() {

    };
    Entered.value = new Entered();
    return Entered;
})();
var Exited = (function () {
    function Exited() {

    };
    Exited.value = new Exited();
    return Exited;
})();
var CycleHead = (function () {
    function CycleHead(value0) {
        this.value0 = value0;
    };
    CycleHead.create = function (value0) {
        return new CycleHead(value0);
    };
    return CycleHead;
})();
var CycleError = (function () {
    function CycleError() {

    };
    CycleError.value = new CycleError();
    return CycleError;
})();
var DFSOrderViolation = (function () {
    function DFSOrderViolation() {

    };
    DFSOrderViolation.value = new DFSOrderViolation();
    return DFSOrderViolation;
})();
var AAM = function (x) {
    return x;
};
var vertices = function (dictOrd) {
    return function (arr) {
        return Data_AdjacencyMap.vertices(dictOrd)(arr);
    };
};
var vertexSet = function (dictOrd) {
    return Data_AdjacencyMap.vertexSet;
};
var vertexCount = Data_AdjacencyMap.vertexCount;
var vertexArray = Data_AdjacencyMap.vertexArray;
var vertex = Data_AdjacencyMap.vertex;
var union = function (dictOrd) {
    return function (dictOrd1) {
        return function (v) {
            return function (v1) {
                return AAM(Data_AdjacencyMap.overlay(Data_Either.ordEither(dictOrd)(dictOrd1))(Data_AdjacencyMap.gmap(dictOrd)(Data_Either.ordEither(dictOrd)(dictOrd1))(Data_Either.Left.create)(v))(Data_AdjacencyMap.gmap(dictOrd1)(Data_Either.ordEither(dictOrd)(dictOrd1))(Data_Either.Right.create)(v1)));
            };
        };
    };
};
var transpose = function (dictOrd) {
    return function (a) {
        return AAM(Data_AdjacencyMap.transpose(dictOrd)(a));
    };
};
var transitiveClosure = function (dictOrd) {
    return function (a) {
        return AAM(Data_AdjacencyMap.transitiveClosure(dictOrd)(a));
    };
};
var showAcyclicAdjacencyMap = function (dictShow) {
    return Data_AdjacencyMap.showAdjacencyMap(dictShow);
};
var removeVertex = function (dictOrd) {
    return function (a) {
        return function (aama) {
            return AAM(Data_AdjacencyMap.removeVertex(dictOrd)(a)(aama));
        };
    };
};
var removeEdge = function (dictOrd) {
    return function (a) {
        return function (b) {
            return function (aama) {
                return AAM(Data_AdjacencyMap.removeEdge(dictOrd)(a)(b)(aama));
            };
        };
    };
};
var preSet = function (dictOrd) {
    return function (a) {
        return function (aama) {
            return Data_AdjacencyMap.preSet(dictOrd)(a)(aama);
        };
    };
};
var postSet = function (dictOrd) {
    return function (a) {
        return function (aama) {
            return Data_AdjacencyMap.postSet(dictOrd)(a)(aama);
        };
    };
};
var join = function (dictOrd) {
    return function (dictOrd1) {
        return function (v) {
            return function (v1) {
                return AAM(Data_AdjacencyMap.connect(Data_Either.ordEither(dictOrd)(dictOrd1))(Data_AdjacencyMap.gmap(dictOrd)(Data_Either.ordEither(dictOrd)(dictOrd1))(Data_Either.Left.create)(v))(Data_AdjacencyMap.gmap(dictOrd1)(Data_Either.ordEither(dictOrd)(dictOrd1))(Data_Either.Right.create)(v1)));
            };
        };
    };
};
var isSubgraphOf = function (dictOrd) {
    return function (v) {
        return function (v1) {
            return Data_AdjacencyMap.isSubgraphOf(dictOrd)(v)(v1);
        };
    };
};
var isEmpty = Data_AdjacencyMap.isEmpty;
var induceJust = function (dictOrd) {
    return function (a) {
        return AAM(Data_AdjacencyMap.induceJust(dictOrd)(a));
    };
};
var induce = function (dictOrd) {
    return function (f) {
        return function (a) {
            return AAM(Data_AdjacencyMap.induce(dictOrd)(f)(a));
        };
    };
};
var hasVertex = function (dictOrd) {
    return function (a) {
        return function (aama) {
            return Data_AdjacencyMap.hasVertex(dictOrd)(a)(aama);
        };
    };
};
var hasEdge = function (dictOrd) {
    return function (a) {
        return function (b) {
            return function (aama) {
                return Data_AdjacencyMap.hasEdge(dictOrd)(a)(b)(aama);
            };
        };
    };
};
var emptyTSS = {
    parent: Data_Map_Internal.empty,
    entry: Data_Map_Internal.empty,
    order: [  ]
};
var empty = Data_AdjacencyMap.empty;
var edgeSet = function (dictEq) {
    return function (dictOrd) {
        return function (a) {
            return Data_AdjacencyMap.edgeSet(dictEq)(dictOrd)(a);
        };
    };
};
var edgeCount = Data_AdjacencyMap.edgeCount;
var edgeArray = function (dictOrd) {
    return function (aama) {
        return Data_AdjacencyMap.edgeArray(dictOrd)(aama);
    };
};
var compare$prime = function (dictOrd) {
    return function (a) {
        return function (b) {
            var v = Data_Ord.compare(dictOrd)(a)(b);
            if (v instanceof Data_Ordering.GT) {
                return Data_Ordering.LT.value;
            };
            if (v instanceof Data_Ordering.EQ) {
                return Data_Ordering.EQ.value;
            };
            if (v instanceof Data_Ordering.LT) {
                return Data_Ordering.GT.value;
            };
            throw new Error("Failed pattern match at Data.AcyclicAdjacencyMap (line 123, column 16 - line 126, column 11): " + [ v.constructor.name ]);
        };
    };
};
var mapToDescendingArray = function (dictOrd) {
    return function (dictOrd1) {
        return function (mkay) {
            return Data_Array.sortBy(compare$prime(Data_Tuple.ordTuple(dictOrd)(dictOrd1)))(Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray)(mkay));
        };
    };
};
var setToDescendingArray = function (dictOrd) {
    return function (sa) {
        return Data_Array.sortBy(compare$prime(dictOrd))(Data_Set.toUnfoldable(Data_Unfoldable.unfoldableArray)(sa));
    };
};
var topSort$prime = function (dictOrd) {
    return function (dictPartial) {
        return function (dictMonadState) {
            return function (dictMonadCont) {
                return function (g) {
                    var nodeState = function (v) {
                        return Control_Monad_State_Class.gets(dictMonadState)((function () {
                            var $77 = Data_Map_Internal.lookup(dictOrd)(v);
                            return function ($78) {
                                return $77((function (v1) {
                                    return v1.entry;
                                })($78));
                            };
                        })());
                    };
                    var leave = function (v) {
                        if (v instanceof Entered) {
                            return Exited.value;
                        };
                        if (v instanceof Exited) {
                            return Effect_Exception_Unsafe.unsafeThrow("Internal error: dfs search order violated");
                        };
                        throw new Error("Failed pattern match at Data.AcyclicAdjacencyMap (line 167, column 11 - line 169, column 70): " + [ v.constructor.name ]);
                    };
                    var exit = function (v) {
                        return Control_Monad_State_Class.modify(dictMonadState)(function (v1) {
                            return {
                                parent: v1.parent,
                                entry: Data_Map_Internal.alter(dictOrd)(Data_Functor.map(Data_Maybe.functorMaybe)(leave))(v)(v1.entry),
                                order: Data_Array.cons(v)(v1.order)
                            };
                        });
                    };
                    var enterRoot = function (v) {
                        return Control_Monad_State_Class.modify(dictMonadState)(function (v1) {
                            return {
                                parent: v1.parent,
                                entry: Data_Map_Internal.insert(dictOrd)(v)(Entered.value)(v1.entry),
                                order: v1.order
                            };
                        });
                    };
                    var enter = function (u) {
                        return function (v) {
                            return Control_Monad_State_Class.modify(dictMonadState)(function (v1) {
                                return {
                                    parent: Data_Map_Internal.insert(dictOrd)(v)(u)(v1.parent),
                                    entry: Data_Map_Internal.insert(dictOrd)(v)(Entered.value)(v1.entry),
                                    order: v1.order
                                };
                            });
                        };
                    };
                    return Control_Monad_Cont_Class.callCC(dictMonadCont)(function (cyclic) {
                        var vertices$prime = Data_Functor.map(Data_Functor.functorArray)(Data_Tuple.fst)(mapToDescendingArray(dictOrd)(Data_Set.ordSet(dictOrd))(Data_Newtype.unwrap()(g)));
                        var adjacent = (function () {
                            var $79 = setToDescendingArray(dictOrd);
                            var $80 = Data_Function.flip(Data_AdjacencyMap.postSet(dictOrd))(g);
                            return function ($81) {
                                return $79($80($81));
                            };
                        })();
                        var dfs = function (x) {
                            return Data_Foldable.for_((dictMonadCont.Monad0()).Applicative0())(Data_Foldable.foldableArray)(adjacent(x))(function (y) {
                                return Control_Bind.bind((dictMonadCont.Monad0()).Bind1())(nodeState(y))(function (v) {
                                    if (v instanceof Data_Maybe.Nothing) {
                                        return Control_Apply.applySecond(((dictMonadCont.Monad0()).Bind1()).Apply0())(Control_Apply.applySecond(((dictMonadCont.Monad0()).Bind1()).Apply0())(enter(x)(y))(dfs(y)))(exit(y));
                                    };
                                    if (v instanceof Data_Maybe.Just && v.value0 instanceof Exited) {
                                        return Control_Applicative.pure((dictMonadCont.Monad0()).Applicative0())(emptyTSS);
                                    };
                                    if (v instanceof Data_Maybe.Just && v.value0 instanceof Entered) {
                                        return Control_Bind.bindFlipped((dictMonadCont.Monad0()).Bind1())(function ($82) {
                                            return cyclic(Data_Either.Left.create(CycleHead.create($82)));
                                        })(Control_Monad_State_Class.gets(dictMonadState)(function (v1) {
                                            return v1.parent;
                                        }));
                                    };
                                    throw new Error("Failed pattern match at Data.AcyclicAdjacencyMap (line 152, column 25 - line 155, column 88): " + [ v.constructor.name ]);
                                });
                            });
                        };
                        var dfsRoot = function (x) {
                            return Control_Bind.bind((dictMonadCont.Monad0()).Bind1())(nodeState(x))(function (v) {
                                if (v instanceof Data_Maybe.Nothing) {
                                    return Control_Apply.applySecond(((dictMonadCont.Monad0()).Bind1()).Apply0())(Control_Apply.applySecond(((dictMonadCont.Monad0()).Bind1()).Apply0())(enterRoot(x))(dfs(x)))(exit(x));
                                };
                                return Control_Applicative.pure((dictMonadCont.Monad0()).Applicative0())(emptyTSS);
                            });
                        };
                        return Control_Bind.discard(Control_Bind.discardUnit)((dictMonadCont.Monad0()).Bind1())(Data_Foldable.for_((dictMonadCont.Monad0()).Applicative0())(Data_Foldable.foldableArray)(vertices$prime)(dfsRoot))(function () {
                            return Data_Functor.map((((dictMonadCont.Monad0()).Bind1()).Apply0()).Functor0())(Data_Either.Right.create)(Control_Monad_State_Class.gets(dictMonadState)(function (v) {
                                return v.order;
                            }));
                        });
                    });
                };
            };
        };
    };
};
var topSort = function (dictOrd) {
    return function (g) {
        return Control_Monad_Cont_Trans.runContT(Control_Monad_State_Trans.evalStateT(Control_Monad_Cont_Trans.functorContT(Data_Either.functorEither))(topSort$prime(dictOrd)()(Control_Monad_State_Trans.monadStateStateT(Control_Monad_Cont_Trans.monadContT(Data_Either.monadEither)))(Control_Monad_State_Trans.monadContStateT(Control_Monad_Cont_Trans.monadContContT(Data_Either.monadEither)))(g))(emptyTSS))(Control_Category.identity(Control_Category.categoryFn));
    };
};
var isAcyclic = function (dictOrd) {
    var $83 = topSort(dictOrd);
    return function ($84) {
        return Data_Either.isRight($83($84));
    };
};
var toAcyclic = function (dictOrd) {
    return function (x) {
        var $76 = isAcyclic(dictOrd)(x);
        if ($76) {
            return new Data_Maybe.Just(x);
        };
        return Data_Maybe.Nothing.value;
    };
};
var box = function (dictOrd) {
    return function (dictOrd1) {
        return function (a) {
            return function (b) {
                return AAM(Data_AdjacencyMap.box(dictOrd)(dictOrd1)(a)(b));
            };
        };
    };
};
var adjacencyArray = function (dictOrd) {
    return function (a) {
        return Data_AdjacencyMap.adjacencyArray(dictOrd)(a);
    };
};
module.exports = {
    AAM: AAM,
    CycleError: CycleError,
    DFSOrderViolation: DFSOrderViolation,
    empty: empty,
    vertex: vertex,
    vertices: vertices,
    union: union,
    join: join,
    isSubgraphOf: isSubgraphOf,
    isEmpty: isEmpty,
    hasVertex: hasVertex,
    hasEdge: hasEdge,
    vertexCount: vertexCount,
    edgeCount: edgeCount,
    vertexArray: vertexArray,
    edgeArray: edgeArray,
    adjacencyArray: adjacencyArray,
    vertexSet: vertexSet,
    edgeSet: edgeSet,
    preSet: preSet,
    postSet: postSet,
    removeVertex: removeVertex,
    removeEdge: removeEdge,
    transpose: transpose,
    induce: induce,
    induceJust: induceJust,
    box: box,
    transitiveClosure: transitiveClosure,
    Entered: Entered,
    Exited: Exited,
    emptyTSS: emptyTSS,
    mapToDescendingArray: mapToDescendingArray,
    setToDescendingArray: setToDescendingArray,
    "compare'": compare$prime,
    CycleHead: CycleHead,
    "topSort'": topSort$prime,
    topSort: topSort,
    isAcyclic: isAcyclic,
    toAcyclic: toAcyclic,
    showAcyclicAdjacencyMap: showAcyclicAdjacencyMap
};
