// Generated by purs version 0.14.5
"use strict";
var $foreign = require("./foreign.js");
var Cardano_Types_Transaction = require("../Cardano.Types.Transaction/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Monad = require("../Control.Monad/index.js");
var Control_Monad_Error_Class = require("../Control.Monad.Error.Class/index.js");
var Control_Promise = require("../Control.Promise/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Newtype = require("../Data.Newtype/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Traversable = require("../Data.Traversable/index.js");
var Deserialization_FromBytes = require("../Deserialization.FromBytes/index.js");
var Deserialization_UnspentOutput = require("../Deserialization.UnspentOutput/index.js");
var Deserialization_WitnessSet = require("../Deserialization.WitnessSet/index.js");
var Effect = require("../Effect/index.js");
var Effect_Aff = require("../Effect.Aff/index.js");
var Effect_Class = require("../Effect.Class/index.js");
var Effect_Exception = require("../Effect.Exception/index.js");
var FfiHelpers = require("../FfiHelpers/index.js");
var Serialization = require("../Serialization/index.js");
var Serialization_Address = require("../Serialization.Address/index.js");
var Types_ByteArray = require("../Types.ByteArray/index.js");
var Types_CborBytes = require("../Types.CborBytes/index.js");
var Types_RawBytes = require("../Types.RawBytes/index.js");
var Untagged_Union = require("../Untagged.Union/index.js");
var txToHex = (function () {
    var $11 = Effect_Class.liftEffect(Effect_Aff.monadEffectAff);
    var $12 = Data_Functor.map(Effect.functorEffect)((function () {
        var $14 = Untagged_Union.asOneOf();
        return function ($15) {
            return Types_ByteArray.byteArrayToHex(Serialization.toBytes($14($15)));
        };
    })());
    return function ($13) {
        return $11($12(Serialization.convertTransaction($13)));
    };
})();
var getWalletAddresses = function (conn) {
    return Data_Functor.mapFlipped(Effect_Aff.functorAff)(Control_Promise.toAffE($foreign["_getAddresses"](conn)))(Data_Traversable.traverse(Data_Traversable.traversableArray)(Data_Maybe.applicativeMaybe)(Control_Bind.composeKleisliFlipped(Data_Maybe.bindMaybe)(function ($16) {
        return Serialization_Address.addressFromBytes(Types_CborBytes.rawBytesAsCborBytes($16));
    })(Types_RawBytes.hexToRawBytes)));
};
var getUtxos = function (conn) {
    return Control_Bind.bind(Effect_Aff.bindAff)(Control_Promise.toAffE($foreign["_getUtxos"](FfiHelpers.maybeFfiHelper)(conn)))(function (mArrayStr) {
        return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Data_Traversable["for"](Effect.applicativeEffect)(Data_Traversable.traversableMaybe)(mArrayStr)(Data_Traversable.traverse(Data_Traversable.traversableArray)(Effect.applicativeEffect)(function (str) {
            return Control_Monad_Error_Class.liftMaybe(Control_Monad_Error_Class.monadThrowEffect)(Effect_Exception.error("Unable to convert UTxO"))(Control_Bind.bind(Data_Maybe.bindMaybe)(Control_Bind.bind(Data_Maybe.bindMaybe)(Types_RawBytes.hexToRawBytes(str))((function () {
                var $17 = Deserialization_FromBytes.fromBytes(Deserialization_FromBytes.fromBytesTransactionUnspe);
                var $18 = Data_Newtype.unwrap();
                return function ($19) {
                    return $17($18($19));
                };
            })()))(Deserialization_UnspentOutput.convertUnspentOutput));
        })));
    });
};
var getCip30Collateral = (function () {
    var $20 = Data_Function.flip(Control_Monad_Error_Class.catchError(Control_Monad_Error_Class.monadErrorEffect))(function (v) {
        return Control_Monad_Error_Class.throwError(Control_Monad_Error_Class.monadThrowEffect)(Effect_Exception.error("Wallet doesn't implement `getCollateral`."));
    });
    var $21 = $foreign["_getCollateral"](FfiHelpers.maybeFfiHelper);
    return function ($22) {
        return $20($21($22));
    };
})();
var getCollateral = function (conn) {
    return Control_Bind.bind(Effect_Aff.bindAff)(Control_Promise.toAffE(getCip30Collateral(conn)))(function (mbUtxoStrs) {
        var v = Control_Bind.join(Data_Maybe.bindMaybe)(Data_Functor.map(Data_Maybe.functorMaybe)(Data_Traversable.traverse(Data_Traversable.traversableArray)(Data_Maybe.applicativeMaybe)(Types_RawBytes.hexToRawBytes))(mbUtxoStrs));
        return Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Data_Traversable["for"](Effect.applicativeEffect)(Data_Traversable.traversableMaybe)(v)(function (collateralUtxos) {
            return Data_Traversable["for"](Effect.applicativeEffect)(Data_Traversable.traversableArray)(collateralUtxos)(function (bytes) {
                return Control_Bind.bindFlipped(Effect.bindEffect)(Data_Maybe.maybe(Effect_Exception["throw"]("Unable to convert UTxO"))(Control_Applicative.pure(Effect.applicativeEffect)))(Data_Functor.map(Effect.functorEffect)(Deserialization_UnspentOutput.convertUnspentOutput)(Deserialization_FromBytes.fromBytesEffect(Deserialization_FromBytes.fromBytesTransactionUnspe)(Data_Newtype.unwrap()(bytes))));
            });
        }));
    });
};
var fromHexString = function (act) {
    var $23 = Data_Functor.map(Effect_Aff.functorAff)(Types_RawBytes.hexToRawBytes);
    return function ($24) {
        return $23(Control_Promise.toAffE(act($24)));
    };
};
var getBalance = function (wallet) {
    return Data_Functor.mapFlipped(Effect_Aff.functorAff)(fromHexString($foreign["_getBalance"])(wallet))(function (mbBytes) {
        return Control_Bind.bind(Data_Maybe.bindMaybe)(mbBytes)(function (bytes) {
            return Control_Bind.bind(Data_Maybe.bindMaybe)(Deserialization_FromBytes.fromBytes(Deserialization_FromBytes.fromBytesValue)(Data_Newtype.unwrap()(bytes)))(Deserialization_UnspentOutput.convertValue);
        });
    });
};
var signTx = function (conn) {
    return function (tx) {
        var combineWitnessSet = function (v) {
            return function (newWits) {
                return Cardano_Types_Transaction.Transaction({
                    body: v.body,
                    witnessSet: Data_Semigroup.append(Cardano_Types_Transaction.semigroupTransactionWitne)(v.witnessSet)(newWits),
                    isValid: v.isValid,
                    auxiliaryData: v.auxiliaryData
                });
            };
        };
        return Control_Bind.bind(Effect_Aff.bindAff)(txToHex(tx))(function (txHex) {
            return Control_Bind.bind(Effect_Aff.bindAff)(fromHexString($foreign["_signTx"](txHex))(conn))(function (v) {
                if (v instanceof Data_Maybe.Nothing) {
                    return Control_Applicative.pure(Effect_Aff.applicativeAff)(Data_Maybe.Nothing.value);
                };
                if (v instanceof Data_Maybe.Just) {
                    return Data_Functor.map(Effect_Aff.functorAff)(Data_Functor.map(Data_Maybe.functorMaybe)(combineWitnessSet(tx)))(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Data_Functor.map(Effect.functorEffect)(Deserialization_WitnessSet.convertWitnessSet)(Deserialization_FromBytes.fromBytesEffect(Deserialization_FromBytes.fromBytesTransactionWitne)(Data_Newtype.unwrap()(v.value0)))));
                };
                throw new Error("Failed pattern match at Wallet.Cip30 (line 116, column 42 - line 121, column 8): " + [ v.constructor.name ]);
            });
        });
    };
};
var mkCip30WalletAff = function (walletName) {
    return function (enableWallet) {
        return Control_Bind.bind(Effect_Aff.bindAff)(Control_Promise.toAffE(enableWallet))(function (wallet) {
            return Control_Bind.discard(Control_Bind.discardUnit)(Effect_Aff.bindAff)(Control_Monad.whenM(Effect_Aff.monadAff)(Data_Functor.map(Effect_Aff.functorAff)(Data_Maybe.isNothing)(getCollateral(wallet)))(Effect_Class.liftEffect(Effect_Aff.monadEffectAff)(Effect_Exception["throw"](walletName + " wallet missing collateral"))))(function () {
                return Control_Applicative.pure(Effect_Aff.applicativeAff)({
                    connection: wallet,
                    getWalletAddresses: getWalletAddresses,
                    getCollateral: getCollateral,
                    signTx: signTx,
                    getBalance: getBalance,
                    getUtxos: getUtxos
                });
            });
        });
    };
};
module.exports = {
    mkCip30WalletAff: mkCip30WalletAff
};
