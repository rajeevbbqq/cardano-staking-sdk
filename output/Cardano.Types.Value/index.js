// Generated by purs version 0.14.5
"use strict";
var Aeson = require("../Aeson/index.js");
var Control_Alt = require("../Control.Alt/index.js");
var Control_Alternative = require("../Control.Alternative/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Data_Argonaut_Decode_Error = require("../Data.Argonaut.Decode.Error/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Bifunctor = require("../Data.Bifunctor/index.js");
var Data_BigInt = require("../Data.BigInt/index.js");
var Data_Bitraversable = require("../Data.Bitraversable/index.js");
var Data_Boolean = require("../Data.Boolean/index.js");
var Data_Either = require("../Data.Either/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_FoldableWithIndex = require("../Data.FoldableWithIndex/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Generic_Rep = require("../Data.Generic.Rep/index.js");
var Data_HeytingAlgebra = require("../Data.HeytingAlgebra/index.js");
var Data_Lattice = require("../Data.Lattice/index.js");
var Data_List = require("../Data.List/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Map = require("../Data.Map/index.js");
var Data_Map_Internal = require("../Data.Map.Internal/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Newtype = require("../Data.Newtype/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ring = require("../Data.Ring/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Semiring = require("../Data.Semiring/index.js");
var Data_Set = require("../Data.Set/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_Show_Generic = require("../Data.Show.Generic/index.js");
var Data_These = require("../Data.These/index.js");
var Data_Traversable = require("../Data.Traversable/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Unfoldable = require("../Data.Unfoldable/index.js");
var FromData = require("../FromData/index.js");
var Helpers = require("../Helpers/index.js");
var Metadata_FromMetadata = require("../Metadata.FromMetadata/index.js");
var Metadata_ToMetadata = require("../Metadata.ToMetadata/index.js");
var Serialization_Hash = require("../Serialization.Hash/index.js");
var ToData = require("../ToData/index.js");
var Types_ByteArray = require("../Types.ByteArray/index.js");
var Types_Scripts = require("../Types.Scripts/index.js");
var Types_TokenName = require("../Types.TokenName/index.js");
var CurrencySymbol = function (x) {
    return x;
};
var NonAdaAsset = function (x) {
    return x;
};
var Coin = function (x) {
    return x;
};
var Value = (function () {
    function Value(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Value.create = function (value0) {
        return function (value1) {
            return new Value(value0, value1);
        };
    };
    return Value;
})();
var toMetadataCurrencySymbol = Metadata_ToMetadata.toMetadataByteArray;
var toDataCurrencySymbol = ToData.toDataByteArray;
var splitCoin = {
    split: function (v) {
        var $127 = Data_Ord.lessThanOrEq(Data_BigInt.ordBigInt)(v)(Data_Semiring.zero(Data_BigInt.semiringBigInt));
        if ($127) {
            return new Data_Tuple.Tuple(Data_Ring.negate(Data_BigInt.ringBigInt)(v), Data_Semiring.zero(Data_BigInt.semiringBigInt));
        };
        return new Data_Tuple.Tuple(Data_Semiring.zero(Data_BigInt.semiringBigInt), v);
    }
};
var showCurrencySymbol = {
    show: function (v) {
        return "(CurrencySymbol " + (Data_Show.show(Types_ByteArray.showByteArray)(v) + ")");
    }
};
var showNonAdaAsset = {
    show: function (v) {
        return "(NonAdaAsset " + (Data_Show.show(Data_Map_Internal.showMap(showCurrencySymbol)(Data_Map_Internal.showMap(Types_TokenName.showTokenName)(Data_BigInt.showBigInt)))(v) + ")");
    }
};
var showCoin = {
    show: function (v) {
        return Helpers.showWithParens(Data_BigInt.showBigInt)("Coin")(v);
    }
};
var semigroupCoin = {
    append: function (v) {
        return function (v1) {
            return Data_Semiring.add(Data_BigInt.semiringBigInt)(v)(v1);
        };
    }
};
var ordCurrencySymbol = Types_ByteArray.ordByteArray;
var ordCoin = Data_BigInt.ordBigInt;
var newtypeCoin_ = {
    Coercible0: function () {
        return undefined;
    }
};
var negateCoin = {
    negation: (function () {
        var $323 = Data_Newtype.wrap();
        var $324 = Data_Ring.negate(Data_BigInt.ringBigInt);
        var $325 = Data_Newtype.unwrap();
        return function ($326) {
            return $323($324($325($326)));
        };
    })()
};
var monoidCoin = {
    mempty: Data_Semiring.zero(Data_BigInt.semiringBigInt),
    Semigroup0: function () {
        return semigroupCoin;
    }
};
var meetSemilatticeCoin = {
    meet: function (v) {
        return function (v1) {
            return Data_Ord.min(Data_BigInt.ordBigInt)(v)(v1);
        };
    }
};
var joinSemilatticeCoin = {
    join: function (v) {
        return function (v1) {
            return Data_Ord.max(Data_BigInt.ordBigInt)(v)(v1);
        };
    }
};
var genericValue_ = {
    to: function (x) {
        return new Value(x.value0, x.value1);
    },
    from: function (x) {
        return new Data_Generic_Rep.Product(x.value0, x.value1);
    }
};
var showValue = {
    show: Data_Show_Generic.genericShow(genericValue_)(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsProduct(Data_Show_Generic.genericShowArgsArgument(showCoin))(Data_Show_Generic.genericShowArgsArgument(showNonAdaAsset)))({
        reflectSymbol: function () {
            return "Value";
        }
    }))
};
var genericCoin_ = {
    to: function (x) {
        return x;
    },
    from: function (x) {
        return x;
    }
};
var fromMetadataCurrencySymbo = Metadata_FromMetadata.fromMetadataByteArray;
var fromDataCurrencySymbol = FromData.fromDataByteArray;
var eqCurrencySymbol = Types_ByteArray.eqByteArray;
var eqNonAdaAsset = Data_Map_Internal.eqMap(eqCurrencySymbol)(Data_Map_Internal.eqMap(Types_TokenName.eqTokenName)(Data_BigInt.eqBigInt));
var eqCoin = Data_BigInt.eqBigInt;
var eqValue = {
    eq: function (x) {
        return function (y) {
            return Data_Eq.eq(eqCoin)(x.value0)(y.value0) && Data_Eq.eq(eqNonAdaAsset)(x.value1)(y.value1);
        };
    }
};
var encodeAesonCurrencySymbol = {
    "encodeAeson'": function (v) {
        return Aeson["encodeAeson'"](Aeson.encodeAesonRecord(Aeson.gEncodeAesonCons(Aeson.encodeAesonString)(Aeson.gEncodeAesonNil)({
            reflectSymbol: function () {
                return "unCurrencySymbol";
            }
        })())())({
            unCurrencySymbol: Types_ByteArray.byteArrayToHex(v)
        });
    }
};
var encodeAesonNonAdaAsset = {
    "encodeAeson'": function (v) {
        return Aeson["encodeAeson'"](Aeson.encodeAesonAeson)(Helpers.encodeMap(encodeAesonCurrencySymbol)(Aeson.encodeAesonAeson)(Data_Functor.map(Data_Map_Internal.functorMap)(Helpers.encodeMap(Types_TokenName.encodeAesonTokenName)(Aeson.encodeAesonBigInt))(v)));
    }
};
var encodeAesonCoin = Aeson.encodeAesonBigInt;
var encodeAesonValue = {
    "encodeAeson'": function (v) {
        return Aeson["encodeAeson'"](Aeson.encodeAesonRecord(Aeson.gEncodeAesonCons(encodeAesonCoin)(Aeson.gEncodeAesonCons(encodeAesonNonAdaAsset)(Aeson.gEncodeAesonNil)({
            reflectSymbol: function () {
                return "nonAdaAsset";
            }
        })())({
            reflectSymbol: function () {
                return "coin";
            }
        })())())({
            coin: v.value0,
            nonAdaAsset: v.value1
        });
    }
};
var unwrapNonAdaAsset = function (v) {
    return v;
};
var negateNonAdaAsset = {
    negation: (function () {
        var $327 = Data_Functor.map(Data_Map_Internal.functorMap)(Data_Functor.map(Data_Map_Internal.functorMap)(Data_Ring.negate(Data_BigInt.ringBigInt)));
        return function ($328) {
            return NonAdaAsset($327(unwrapNonAdaAsset($328)));
        };
    })()
};
var unsafeAllTokenNames$prime = function (v) {
    var nonAdaUnion = Data_Map_Internal.unions(Types_TokenName.ordTokenName)(Data_List_Types.foldableList)(Data_Map_Internal.values(v.value1));
    var v1 = Data_Eq.eq(eqCoin)(v.value0)(Data_Monoid.mempty(monoidCoin));
    if (!v1) {
        return nonAdaUnion;
    };
    if (v1) {
        return Data_Map_Internal.union(Types_TokenName.ordTokenName)(Data_Map_Internal.singleton(Types_TokenName.adaToken)(v.value0))(nonAdaUnion);
    };
    throw new Error("Failed pattern match at Cardano.Types.Value (line 664, column 5 - line 666, column 71): " + [ v1.constructor.name ]);
};
var unsafeAllTokenNames = function ($329) {
    return Data_Map.keys(unsafeAllTokenNames$prime($329));
};
var unsafeAdaSymbol = Data_Monoid.mempty(Types_ByteArray.monoidByteArray);
var unsafeIsAda = function (curSymbol) {
    return function (tokenName) {
        return Data_Eq.eq(eqCurrencySymbol)(curSymbol)(unsafeAdaSymbol) && Data_Eq.eq(Types_TokenName.eqTokenName)(tokenName)(Types_TokenName.adaToken);
    };
};
var valueOf = function (v) {
    return function (curSymbol) {
        return function (tokenName) {
            var v1 = unsafeIsAda(curSymbol)(tokenName);
            if (!v1) {
                var v2 = Data_Map_Internal.lookup(ordCurrencySymbol)(curSymbol)(v.value1);
                if (v2 instanceof Data_Maybe.Nothing) {
                    return Data_Semiring.zero(Data_BigInt.semiringBigInt);
                };
                if (v2 instanceof Data_Maybe.Just) {
                    var v3 = Data_Map_Internal.lookup(Types_TokenName.ordTokenName)(tokenName)(v2.value0);
                    if (v3 instanceof Data_Maybe.Nothing) {
                        return Data_Semiring.zero(Data_BigInt.semiringBigInt);
                    };
                    if (v3 instanceof Data_Maybe.Just) {
                        return v3.value0;
                    };
                    throw new Error("Failed pattern match at Cardano.Types.Value (line 631, column 19 - line 633, column 22): " + [ v3.constructor.name ]);
                };
                throw new Error("Failed pattern match at Cardano.Types.Value (line 629, column 7 - line 633, column 22): " + [ v2.constructor.name ]);
            };
            if (v1) {
                return v.value0;
            };
            throw new Error("Failed pattern match at Cardano.Types.Value (line 627, column 3 - line 634, column 22): " + [ v1.constructor.name ]);
        };
    };
};
var valueToCoin$prime = function (v) {
    return valueOf(v)(unsafeAdaSymbol)(Types_TokenName.adaToken);
};
var valueToCoin = function ($330) {
    return Coin(valueToCoin$prime($330));
};
var union = function (dictOrd) {
    return function (l) {
        return function (r) {
            var rs = Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray)(r);
            var ls = Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray)(l);
            var rs$prime = Data_Array.filter(function (v) {
                return !Data_Foldable.any(Data_Foldable.foldableArray)(Data_HeytingAlgebra.heytingAlgebraBoolean)(function (v1) {
                    return Data_Eq.eq(dictOrd.Eq0())(v1.value0)(v.value0);
                })(ls);
            })(rs);
            var rs$prime$prime = Data_Functor.map(Data_Functor.functorArray)(Data_Functor.map(Data_Tuple.functorTuple)(Data_These.That.create))(rs$prime);
            var f = function (a) {
                return function (b$prime) {
                    if (b$prime instanceof Data_Maybe.Nothing) {
                        return new Data_These.This(a);
                    };
                    if (b$prime instanceof Data_Maybe.Just) {
                        return new Data_These.Both(a, b$prime.value0);
                    };
                    throw new Error("Failed pattern match at Cardano.Types.Value (line 438, column 14 - line 440, column 25): " + [ b$prime.constructor.name ]);
                };
            };
            var ls$prime = Data_Functor.map(Data_Functor.functorArray)(function (v) {
                return new Data_Tuple.Tuple(v.value0, f(v.value1)(Data_Map_Internal.lookup(dictOrd)(v.value0)(Data_Map_Internal.fromFoldable(dictOrd)(Data_Foldable.foldableArray)(rs))));
            })(ls);
            return Data_Map_Internal.fromFoldable(dictOrd)(Data_Foldable.foldableArray)(Data_Semigroup.append(Data_Semigroup.semigroupArray)(ls$prime)(rs$prime$prime));
        };
    };
};
var unionNonAda = function (v) {
    return function (v1) {
        var unBoth = function (k) {
            if (k instanceof Data_These.This) {
                return Data_Functor.map(Data_Map_Internal.functorMap)(Data_These.This.create)(k.value0);
            };
            if (k instanceof Data_These.That) {
                return Data_Functor.map(Data_Map_Internal.functorMap)(Data_These.That.create)(k.value0);
            };
            if (k instanceof Data_These.Both) {
                return union(Types_TokenName.ordTokenName)(k.value0)(k.value1);
            };
            throw new Error("Failed pattern match at Cardano.Types.Value (line 469, column 16 - line 472, column 28): " + [ k.constructor.name ]);
        };
        var combined = union(ordCurrencySymbol)(v)(v1);
        return Data_Functor.map(Data_Map_Internal.functorMap)(unBoth)(combined);
    };
};
var sumTokenNameLengths = (function () {
    var lenAdd = function (c) {
        return function (a) {
            return Data_Semiring.add(Data_BigInt.semiringBigInt)(c)(Data_BigInt.fromInt(Types_ByteArray.byteLength(Types_TokenName.getTokenName(a))));
        };
    };
    var $331 = Data_Foldable.foldl(Data_Set.foldableSet)(lenAdd)(Data_Semiring.zero(Data_BigInt.semiringBigInt));
    return function ($332) {
        return $331(unsafeAllTokenNames($332));
    };
})();
var split = function (dict) {
    return dict.split;
};
var scriptHashAsCurrencySymbol = (function () {
    var $333 = Data_Newtype.unwrap();
    return function ($334) {
        return CurrencySymbol($333(Serialization_Hash.scriptHashToBytes($334)));
    };
})();
var numTokenNames = (function () {
    var $335 = Data_Foldable.length(Data_Map_Internal.foldableMap)(Data_BigInt.semiringBigInt);
    return function ($336) {
        return $335(unsafeAllTokenNames$prime($336));
    };
})();
var negation = function (dict) {
    return dict.negation;
};
var negateValue = {
    negation: function (v) {
        return new Value(negation(negateCoin)(v.value0), negation(negateNonAdaAsset)(v.value1));
    }
};
var mkValue = Value.create;
var mkUnsafeAdaSymbol = function (byteArr) {
    var $194 = Data_Eq.eq(Types_ByteArray.eqByteArray)(byteArr)(Data_Monoid.mempty(Types_ByteArray.monoidByteArray));
    if ($194) {
        return Control_Applicative.pure(Data_Maybe.applicativeMaybe)(unsafeAdaSymbol);
    };
    return Data_Maybe.Nothing.value;
};
var mkCurrencySymbol = function (byteArr) {
    return Control_Apply.applySecond(Data_Maybe.applyMaybe)(Serialization_Hash.scriptHashFromBytes(Data_Newtype.wrap()(byteArr)))(Control_Applicative.pure(Data_Maybe.applicativeMaybe)(byteArr));
};
var mkNonAdaAssets$prime = function (dictTraversable) {
    return function (dictTraversable1) {
        var $337 = Data_Functor.map(Data_Maybe.functorMaybe)(Data_Map_Internal.fromFoldable(ordCurrencySymbol)(dictTraversable.Foldable1()));
        var $338 = Data_Traversable.traverse(dictTraversable)(Data_Maybe.applicativeMaybe)(Data_Bitraversable.bitraverse(Data_Bitraversable.bitraversableTuple)(Data_Maybe.applicativeMaybe)(mkCurrencySymbol)(Types_TokenName.mkTokenNames(dictTraversable1)));
        return function ($339) {
            return $337($338($339));
        };
    };
};
var mkNonAdaAssetsFromTokenMap$prime = function (dictTraversable) {
    var $340 = Data_Functor.map(Data_Maybe.functorMaybe)(Data_Map_Internal.fromFoldable(ordCurrencySymbol)(dictTraversable.Foldable1()));
    var $341 = Data_Traversable.traverse(dictTraversable)(Data_Maybe.applicativeMaybe)(Data_Bitraversable.ltraverse(Data_Bitraversable.bitraversableTuple)(Data_Maybe.applicativeMaybe)(mkCurrencySymbol));
    return function ($342) {
        return $340($341($342));
    };
};
var mpsSymbol = function (v) {
    return mkCurrencySymbol(Data_Newtype.unwrap()(Serialization_Hash.scriptHashToBytes(v)));
};
var decodeAesonCurrencySymbol = {
    decodeAeson: Aeson.caseAesonObject(Data_Either.Left.create(new Data_Argonaut_Decode_Error.TypeMismatch("Expected object")))(Control_Bind.composeKleisliFlipped(Data_Either.bindEither)((function () {
        var $343 = Data_Either.note(new Data_Argonaut_Decode_Error.TypeMismatch("Invalid CurrencySymbol"));
        return function ($344) {
            return $343(mkCurrencySymbol($344));
        };
    })())(Control_Bind.composeKleisliFlipped(Data_Either.bindEither)((function () {
        var $345 = Data_Either.note(new Data_Argonaut_Decode_Error.TypeMismatch("Invalid ByteArray"));
        return function ($346) {
            return $345(Types_ByteArray.hexToByteArray($346));
        };
    })())(Data_Function.flip(Aeson.getField(Aeson.decodeAesonString))("unCurrencySymbol"))))
};
var mkCoin = function ($347) {
    return Coin(Data_BigInt.fromInt($347));
};
var mapThese = function (dictOrd) {
    return function (f) {
        return function (mps) {
            var mps$prime = Data_Functor.map(Data_Map_Internal.functorMap)(f)(mps);
            var f$prime = function (k) {
                return function (v) {
                    return function (v1) {
                        if (v instanceof Data_These.This) {
                            return new Data_Tuple.Tuple(Data_Array.cons(new Data_Tuple.Tuple(k, v.value0))(v1.value0), v1.value1);
                        };
                        if (v instanceof Data_These.That) {
                            return new Data_Tuple.Tuple(v1.value0, Data_Array.cons(new Data_Tuple.Tuple(k, v.value0))(v1.value1));
                        };
                        if (v instanceof Data_These.Both) {
                            return new Data_Tuple.Tuple(Data_Array.cons(new Data_Tuple.Tuple(k, v.value0))(v1.value0), Data_Array.cons(new Data_Tuple.Tuple(k, v.value1))(v1.value1));
                        };
                        throw new Error("Failed pattern match at Cardano.Types.Value (line 733, column 23 - line 736, column 57): " + [ v.constructor.name ]);
                    };
                };
            };
            return Data_Bifunctor.bimap(Data_Bifunctor.bifunctorTuple)(Data_Map_Internal.fromFoldable(dictOrd)(Data_Foldable.foldableArray))(Data_Map_Internal.fromFoldable(dictOrd)(Data_Foldable.foldableArray))(Data_FoldableWithIndex.foldrWithIndex(Data_Map_Internal.foldableWithIndexMap)(f$prime)(new Data_Tuple.Tuple([  ], [  ]))(mps$prime));
        };
    };
};
var splitNonAdaAsset = {
    split: function (v) {
        var splitIntl = function (mp$prime) {
            var v1 = mapThese(Types_TokenName.ordTokenName)(function (i) {
                var $207 = Data_Ord.lessThanOrEq(Data_BigInt.ordBigInt)(i)(Data_Semiring.zero(Data_BigInt.semiringBigInt));
                if ($207) {
                    return new Data_These.This(Data_Ring.negate(Data_BigInt.ringBigInt)(i));
                };
                return new Data_These.That(i);
            })(mp$prime);
            return new Data_These.Both(v1.value0, v1.value1);
        };
        var v1 = mapThese(ordCurrencySymbol)(splitIntl)(v);
        return new Data_Tuple.Tuple(v1.value0, v1.value1);
    }
};
var isZero = function (v) {
    return Data_Foldable.all(Data_Map_Internal.foldableMap)(Data_HeytingAlgebra.heytingAlgebraBoolean)(Data_Foldable.all(Data_Map_Internal.foldableMap)(Data_HeytingAlgebra.heytingAlgebraBoolean)(Data_Eq.eq(Data_BigInt.eqBigInt)(Data_Semiring.zero(Data_BigInt.semiringBigInt))))(v.value1) && Data_Eq.eq(eqCoin)(v.value0)(Data_Monoid.mempty(monoidCoin));
};
var getNonAdaAsset$prime = function (v) {
    return v.value1;
};
var getNonAdaAsset = function (v) {
    return v.value1;
};
var getLovelace = function (v) {
    return v;
};
var getCurrencySymbol = function (v) {
    return v;
};
var flattenNonAdaValue = function (v) {
    return Control_Bind.bind(Data_List_Types.bindList)(Data_Map_Internal.toUnfoldable(Data_List_Types.unfoldableList)(v))(function (v1) {
        return Control_Bind.bind(Data_List_Types.bindList)(Data_Map_Internal.toUnfoldable(Data_List_Types.unfoldableList)(v1.value1))(function (v2) {
            return Control_Bind.discard(Control_Bind.discardUnit)(Data_List_Types.bindList)(Control_Alternative.guard(Data_List_Types.alternativeList)(Data_Eq.notEq(Data_BigInt.eqBigInt)(v2.value1)(Data_Semiring.zero(Data_BigInt.semiringBigInt))))(function () {
                return Control_Applicative.pure(Data_List_Types.applicativeList)(new Data_Tuple.Tuple(v1.value0, new Data_Tuple.Tuple(v2.value0, v2.value1)));
            });
        });
    });
};
var numNonAdaAssets = function (v) {
    return Data_Foldable.length(Data_List_Types.foldableList)(Data_BigInt.semiringBigInt)(flattenNonAdaValue(v.value1));
};
var numNonAdaCurrencySymbols = function (v) {
    return Data_BigInt.fromInt(Data_Foldable.length(Data_List_Types.foldableList)(Data_Semiring.semiringInt)(Data_List.nubByEq(Data_Function.on(Data_Eq.eq(eqCurrencySymbol))(Data_Tuple.fst))(flattenNonAdaValue(v.value1))));
};
var numCurrencySymbols = function (v) {
    if (Data_Eq.eq(eqCoin)(v.value0)(Data_Monoid.mempty(monoidCoin))) {
        return numNonAdaCurrencySymbols(v);
    };
    if (Data_Boolean.otherwise) {
        return Data_Semiring.add(Data_BigInt.semiringBigInt)(Data_Semiring.one(Data_BigInt.semiringBigInt))(numNonAdaCurrencySymbols(v));
    };
    throw new Error("Failed pattern match at Cardano.Types.Value (line 650, column 1 - line 650, column 38): " + [ v.constructor.name ]);
};
var unsafeFlattenValue = function (v) {
    var flattenedNonAda = flattenNonAdaValue(v.value1);
    var v1 = Data_Eq.eq(eqCoin)(v.value0)(Data_Monoid.mempty(monoidCoin));
    if (v1) {
        return flattenedNonAda;
    };
    if (!v1) {
        return new Data_List_Types.Cons(new Data_Tuple.Tuple(unsafeAdaSymbol, new Data_Tuple.Tuple(Types_TokenName.adaToken, v.value0)), flattenedNonAda);
    };
    throw new Error("Failed pattern match at Cardano.Types.Value (line 524, column 5 - line 526, column 76): " + [ v1.constructor.name ]);
};
var isAdaOnly = function (v) {
    var v1 = unsafeFlattenValue(v);
    if (v1 instanceof Data_List_Types.Cons && v1.value1 instanceof Data_List_Types.Nil) {
        return Data_Eq.eq(eqCurrencySymbol)(v1.value0.value0)(unsafeAdaSymbol) && Data_Eq.eq(Types_TokenName.eqTokenName)(v1.value0.value1.value0)(Types_TokenName.adaToken);
    };
    return false;
};
var isPos = (function () {
    var $348 = Data_Foldable.all(Data_List_Types.foldableList)(Data_HeytingAlgebra.heytingAlgebraBoolean)(function (v) {
        return Data_Ord.greaterThan(Data_BigInt.ordBigInt)(v.value1.value1)(Data_Semiring.zero(Data_BigInt.semiringBigInt));
    });
    return function ($349) {
        return $348(unsafeFlattenValue($349));
    };
})();
var filterNonAdaAsset = function (p) {
    return function (v) {
        return NonAdaAsset(Data_Map_Internal.filter(ordCurrencySymbol)(Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraFunction(Data_HeytingAlgebra.heytingAlgebraBoolean))(Data_Map_Internal.isEmpty))(Data_Functor.map(Data_Map_Internal.functorMap)(Data_Map_Internal.filter(Types_TokenName.ordTokenName)(p))(v)));
    };
};
var normalizeNonAdaAsset = filterNonAdaAsset(Data_Eq.notEq(Data_BigInt.eqBigInt)(Data_Semiring.zero(Data_BigInt.semiringBigInt)));
var mkNonAdaAsset = function ($350) {
    return normalizeNonAdaAsset(NonAdaAsset($350));
};
var mkNonAdaAssets = function (dictTraversable) {
    return function (dictTraversable1) {
        return function (xs) {
            return Data_Functor.mapFlipped(Data_Maybe.functorMaybe)(mkNonAdaAssets$prime(dictTraversable)(dictTraversable1)(xs))(mkNonAdaAsset);
        };
    };
};
var mkNonAdaAssetsFromTokenMap = function (dictTraversable) {
    return function (xs) {
        return Data_Functor.mapFlipped(Data_Maybe.functorMaybe)(mkNonAdaAssetsFromTokenMap$prime(dictTraversable)(xs))(mkNonAdaAsset);
    };
};
var unionWithNonAda = function (f) {
    return function (ls) {
        return function (rs) {
            var unBoth = function (k$prime) {
                if (k$prime instanceof Data_These.This) {
                    return f(k$prime.value0)(Data_Semiring.zero(Data_BigInt.semiringBigInt));
                };
                if (k$prime instanceof Data_These.That) {
                    return f(Data_Semiring.zero(Data_BigInt.semiringBigInt))(k$prime.value0);
                };
                if (k$prime instanceof Data_These.Both) {
                    return f(k$prime.value0)(k$prime.value1);
                };
                throw new Error("Failed pattern match at Cardano.Types.Value (line 489, column 17 - line 492, column 24): " + [ k$prime.constructor.name ]);
            };
            var combined = unionNonAda(ls)(rs);
            return normalizeNonAdaAsset(Data_Functor.map(Data_Map_Internal.functorMap)(Data_Functor.map(Data_Map_Internal.functorMap)(unBoth))(combined));
        };
    };
};
var unionWith = function (f) {
    return function (v) {
        return function (v1) {
            return new Value(Coin(f(v.value0)(v1.value0)), unionWithNonAda(f)(v.value1)(v1.value1));
        };
    };
};
var joinSemilatticeNonAdaAsse = {
    join: unionWithNonAda(Data_Ord.max(Data_BigInt.ordBigInt))
};
var joinSemilatticeValue = {
    join: function (v) {
        return function (v1) {
            return new Value(Data_Lattice.join(joinSemilatticeCoin)(v.value0)(v1.value0), Data_Lattice.join(joinSemilatticeNonAdaAsse)(v.value1)(v1.value1));
        };
    }
};
var meetSemilatticeNonAdaAsse = {
    meet: unionWithNonAda(Data_Ord.min(Data_BigInt.ordBigInt))
};
var meetSemilatticeValue = {
    meet: function (v) {
        return function (v1) {
            return new Value(Data_Lattice.meet(meetSemilatticeCoin)(v.value0)(v1.value0), Data_Lattice.meet(meetSemilatticeNonAdaAsse)(v.value1)(v1.value1));
        };
    }
};
var semigroupNonAdaAsset = {
    append: unionWithNonAda(Data_Semiring.add(Data_BigInt.semiringBigInt))
};
var monoidNonAdaAsset = {
    mempty: Data_Map_Internal.empty,
    Semigroup0: function () {
        return semigroupNonAdaAsset;
    }
};
var lovelaceValueOf = Data_Function.flip(function ($351) {
    return Value.create(Coin($351));
})(Data_Monoid.mempty(monoidNonAdaAsset));
var mkSingletonNonAdaAsset = function (curSymbol) {
    return function (tokenName) {
        return function (amount) {
            if (Data_Eq.eq(Data_BigInt.eqBigInt)(amount)(Data_Semiring.zero(Data_BigInt.semiringBigInt))) {
                return Data_Monoid.mempty(monoidNonAdaAsset);
            };
            if (Data_Boolean.otherwise) {
                return NonAdaAsset(Data_Map_Internal.singleton(curSymbol)(Data_Map_Internal.singleton(tokenName)(amount)));
            };
            throw new Error("Failed pattern match at Cardano.Types.Value (line 283, column 1 - line 287, column 17): " + [ curSymbol.constructor.name, tokenName.constructor.name, amount.constructor.name ]);
        };
    };
};
var mkSingletonValue$prime = function (curSymbol) {
    return function (tokenName) {
        return function (amount) {
            var isAdaCs = Data_Eq.eq(eqCurrencySymbol)(curSymbol)(unsafeAdaSymbol);
            return Control_Bind.discard(Control_Bind.discardUnit)(Data_Maybe.bindMaybe)(Control_Alternative.guard(Data_Maybe.alternativeMaybe)(!isAdaCs || isAdaCs && Data_Eq.eq(Types_TokenName.eqTokenName)(tokenName)(Types_TokenName.adaToken)))(function () {
                return Control_Applicative.pure(Data_Maybe.applicativeMaybe)((function () {
                    if (isAdaCs) {
                        return new Value(amount, Data_Monoid.mempty(monoidNonAdaAsset));
                    };
                    return Value.create(Data_Monoid.mempty(monoidCoin))(mkSingletonNonAdaAsset(curSymbol)(tokenName)(amount));
                })());
            });
        };
    };
};
var mkSingletonValue = function (curSymbol$prime) {
    return function (tokenName$prime) {
        return function (amount) {
            return Control_Bind.bind(Data_Maybe.bindMaybe)(Control_Alt.alt(Data_Maybe.altMaybe)(mkCurrencySymbol(curSymbol$prime))(mkUnsafeAdaSymbol(curSymbol$prime)))(function (curSymbol) {
                return Control_Bind.bind(Data_Maybe.bindMaybe)(Types_TokenName.mkTokenName(tokenName$prime))(function (tokenName) {
                    return mkSingletonValue$prime(curSymbol)(tokenName)(amount);
                });
            });
        };
    };
};
var unflattenValue = function (v) {
    return mkSingletonValue$prime(v.value0)(v.value1.value0)(v.value1.value1);
};
var semigroupValue = {
    append: function (v) {
        return function (v1) {
            return new Value(Data_Semigroup.append(semigroupCoin)(v.value0)(v1.value0), Data_Semigroup.append(semigroupNonAdaAsset)(v.value1)(v1.value1));
        };
    }
};
var monoidValue = {
    mempty: new Value(Data_Monoid.mempty(monoidCoin), Data_Monoid.mempty(monoidNonAdaAsset)),
    Semigroup0: function () {
        return semigroupValue;
    }
};
var minus = function (lhs) {
    return function (rhs) {
        var negativeValues = Data_Functor.mapFlipped(Data_List_Types.functorList)(unsafeFlattenValue(rhs))(function (v) {
            return new Data_Tuple.Tuple(v.value0, new Data_Tuple.Tuple(v.value1.value0, Data_Ring.negate(Data_BigInt.ringBigInt)(v.value1.value1)));
        });
        return Data_Semigroup.append(semigroupValue)(lhs)(Data_Foldable.fold(Data_List_Types.foldableList)(monoidValue)(Data_Maybe.fromJust()(Data_Traversable.traverse(Data_List_Types.traversableList)(Data_Maybe.applicativeMaybe)(unflattenValue)(negativeValues))));
    };
};
var splitValue = {
    split: function (v) {
        return Data_Semigroup.append(Data_Tuple.semigroupTuple(semigroupValue)(semigroupValue))(Data_Bifunctor.bimap(Data_Bifunctor.bifunctorTuple)(Data_Function.flip(Value.create)(Data_Monoid.mempty(monoidNonAdaAsset)))(Data_Function.flip(Value.create)(Data_Monoid.mempty(monoidNonAdaAsset)))(split(splitCoin)(v.value0)))(Data_Bifunctor.bimap(Data_Bifunctor.bifunctorTuple)(Value.create(Data_Monoid.mempty(monoidCoin)))(Value.create(Data_Monoid.mempty(monoidCoin)))(split(splitNonAdaAsset)(v.value1)));
    }
};
var posNonAdaAsset = filterNonAdaAsset(function (x) {
    return Data_Ord.greaterThan(Data_BigInt.ordBigInt)(x)(Data_Semiring.zero(Data_BigInt.semiringBigInt));
});
var filterNonAda = function (v) {
    return new Value(Data_Monoid.mempty(monoidCoin), v.value1);
};
var currencyScriptHash = function (v) {
    return Data_Maybe.fromJust()(Serialization_Hash.scriptHashFromBytes(Data_Newtype.wrap()(v)));
};
var currencyMPSHash = function ($352) {
    return Types_Scripts.MintingPolicyHash(currencyScriptHash($352));
};
var coinToValue = function (v) {
    return lovelaceValueOf(v);
};
var checkPred = function (f) {
    return function (v) {
        return function (v1) {
            var inner = Data_Foldable.all(Data_Map_Internal.foldableMap)(Data_HeytingAlgebra.heytingAlgebraBoolean)(f);
            return f(new Data_These.Both(v.value0, v1.value0)) && Data_Foldable.all(Data_Map_Internal.foldableMap)(Data_HeytingAlgebra.heytingAlgebraBoolean)(inner)(unionNonAda(v.value1)(v1.value1));
        };
    };
};
var checkBinRel = function (f) {
    return function (l) {
        return function (r) {
            var unThese = function (k$prime) {
                if (k$prime instanceof Data_These.This) {
                    return f(k$prime.value0)(Data_Semiring.zero(Data_BigInt.semiringBigInt));
                };
                if (k$prime instanceof Data_These.That) {
                    return f(Data_Semiring.zero(Data_BigInt.semiringBigInt))(k$prime.value0);
                };
                if (k$prime instanceof Data_These.Both) {
                    return f(k$prime.value0)(k$prime.value1);
                };
                throw new Error("Failed pattern match at Cardano.Types.Value (line 581, column 18 - line 584, column 24): " + [ k$prime.constructor.name ]);
            };
            return checkPred(unThese)(l)(r);
        };
    };
};
var eq = checkBinRel(Data_Eq.eq(Data_BigInt.eqBigInt));
var geq = checkBinRel(Data_Ord.greaterThanOrEq(Data_BigInt.ordBigInt));
var gt = function (l) {
    return function (r) {
        return !(isZero(l) && isZero(r)) && checkBinRel(Data_Ord.greaterThan(Data_BigInt.ordBigInt))(l)(r);
    };
};
var leq = checkBinRel(Data_Ord.lessThanOrEq(Data_BigInt.ordBigInt));
var lt = function (l) {
    return function (r) {
        return !(isZero(l) && isZero(r)) && checkBinRel(Data_Ord.lessThan(Data_BigInt.ordBigInt))(l)(r);
    };
};
module.exports = {
    Coin: Coin,
    Value: Value,
    coinToValue: coinToValue,
    currencyMPSHash: currencyMPSHash,
    eq: eq,
    filterNonAda: filterNonAda,
    flattenNonAdaValue: flattenNonAdaValue,
    geq: geq,
    getCurrencySymbol: getCurrencySymbol,
    getLovelace: getLovelace,
    getNonAdaAsset: getNonAdaAsset,
    "getNonAdaAsset'": getNonAdaAsset$prime,
    gt: gt,
    isAdaOnly: isAdaOnly,
    isPos: isPos,
    isZero: isZero,
    leq: leq,
    lovelaceValueOf: lovelaceValueOf,
    lt: lt,
    minus: minus,
    mkCoin: mkCoin,
    mkCurrencySymbol: mkCurrencySymbol,
    mkNonAdaAsset: mkNonAdaAsset,
    mkNonAdaAssets: mkNonAdaAssets,
    mkNonAdaAssetsFromTokenMap: mkNonAdaAssetsFromTokenMap,
    mkSingletonNonAdaAsset: mkSingletonNonAdaAsset,
    mkSingletonValue: mkSingletonValue,
    "mkSingletonValue'": mkSingletonValue$prime,
    mkValue: mkValue,
    mpsSymbol: mpsSymbol,
    negation: negation,
    numCurrencySymbols: numCurrencySymbols,
    numNonAdaAssets: numNonAdaAssets,
    numNonAdaCurrencySymbols: numNonAdaCurrencySymbols,
    numTokenNames: numTokenNames,
    posNonAdaAsset: posNonAdaAsset,
    split: split,
    sumTokenNameLengths: sumTokenNameLengths,
    scriptHashAsCurrencySymbol: scriptHashAsCurrencySymbol,
    unionWith: unionWith,
    unionWithNonAda: unionWithNonAda,
    unwrapNonAdaAsset: unwrapNonAdaAsset,
    valueOf: valueOf,
    valueToCoin: valueToCoin,
    "valueToCoin'": valueToCoin$prime,
    genericCoin_: genericCoin_,
    newtypeCoin_: newtypeCoin_,
    eqCoin: eqCoin,
    ordCoin: ordCoin,
    encodeAesonCoin: encodeAesonCoin,
    showCoin: showCoin,
    semigroupCoin: semigroupCoin,
    monoidCoin: monoidCoin,
    joinSemilatticeCoin: joinSemilatticeCoin,
    meetSemilatticeCoin: meetSemilatticeCoin,
    negateCoin: negateCoin,
    splitCoin: splitCoin,
    eqCurrencySymbol: eqCurrencySymbol,
    fromDataCurrencySymbol: fromDataCurrencySymbol,
    fromMetadataCurrencySymbo: fromMetadataCurrencySymbo,
    ordCurrencySymbol: ordCurrencySymbol,
    toDataCurrencySymbol: toDataCurrencySymbol,
    toMetadataCurrencySymbol: toMetadataCurrencySymbol,
    showCurrencySymbol: showCurrencySymbol,
    decodeAesonCurrencySymbol: decodeAesonCurrencySymbol,
    encodeAesonCurrencySymbol: encodeAesonCurrencySymbol,
    eqNonAdaAsset: eqNonAdaAsset,
    showNonAdaAsset: showNonAdaAsset,
    semigroupNonAdaAsset: semigroupNonAdaAsset,
    monoidNonAdaAsset: monoidNonAdaAsset,
    joinSemilatticeNonAdaAsse: joinSemilatticeNonAdaAsse,
    meetSemilatticeNonAdaAsse: meetSemilatticeNonAdaAsse,
    negateNonAdaAsset: negateNonAdaAsset,
    splitNonAdaAsset: splitNonAdaAsset,
    encodeAesonNonAdaAsset: encodeAesonNonAdaAsset,
    genericValue_: genericValue_,
    eqValue: eqValue,
    showValue: showValue,
    semigroupValue: semigroupValue,
    monoidValue: monoidValue,
    joinSemilatticeValue: joinSemilatticeValue,
    meetSemilatticeValue: meetSemilatticeValue,
    negateValue: negateValue,
    splitValue: splitValue,
    encodeAesonValue: encodeAesonValue
};
