// Generated by purs version 0.14.5
"use strict";
var Control_Alternative = require("../Control.Alternative/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Category = require("../Control.Category/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Bifunctor = require("../Data.Bifunctor/index.js");
var Data_Boolean = require("../Data.Boolean/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_FoldableWithIndex = require("../Data.FoldableWithIndex/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_FunctorWithIndex = require("../Data.FunctorWithIndex/index.js");
var Data_HashMap = require("../Data.HashMap/index.js");
var Data_HeytingAlgebra = require("../Data.HeytingAlgebra/index.js");
var Data_Map = require("../Data.Map/index.js");
var Data_Map_Internal = require("../Data.Map.Internal/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Newtype = require("../Data.Newtype/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Semiring = require("../Data.Semiring/index.js");
var Data_Set = require("../Data.Set/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Unfoldable = require("../Data.Unfoldable/index.js");
var AM = function (x) {
    return x;
};
var vertices = function (dictOrd) {
    var $159 = Data_Map_Internal.fromFoldable(dictOrd)(Data_Foldable.foldableArray);
    var $160 = Data_Functor.map(Data_Functor.functorArray)(function (x) {
        return new Data_Tuple.Tuple(x, Data_Set.empty);
    });
    return function ($161) {
        return AM($159($160($161)));
    };
};
var vertex = function (x) {
    return AM(Data_Map_Internal.singleton(x)(Data_Set.empty));
};
var unionsWith = function (dictOrd) {
    return function (dictFoldable) {
        return function (f) {
            return Data_Foldable.foldl(dictFoldable)(Data_Map_Internal.unionWith(dictOrd)(f))(Data_Map_Internal.empty);
        };
    };
};
var submap$prime = function (dictOrd) {
    return function (f) {
        return function (m1) {
            return function (m2) {
                if (Data_Map_Internal.isEmpty(m1)) {
                    return true;
                };
                if (Data_Map_Internal.isEmpty(m2)) {
                    return false;
                };
                if (Data_Boolean.otherwise) {
                    var m1Keys = Data_Set.toUnfoldable(Data_Unfoldable.unfoldableArray)(Data_Map.keys(m1));
                    var m1Values = Data_Array.catMaybes(Data_Functor.map(Data_Functor.functorArray)(function (k) {
                        return Data_Map_Internal.lookup(dictOrd)(k)(m1);
                    })(m1Keys));
                    var m2Lookups = Data_Array.catMaybes(Data_Functor.map(Data_Functor.functorArray)(function (k) {
                        return Data_Map_Internal.lookup(dictOrd)(k)(m2);
                    })(m1Keys));
                    var allMatch = Data_Array.length(m1Values) === Data_Array.length(m2Lookups) && Data_Foldable.and(Data_Foldable.foldableArray)(Data_HeytingAlgebra.heytingAlgebraBoolean)(Control_Apply.apply(Control_Apply.applyArray)(Data_Functor.map(Data_Functor.functorArray)(f)(m1Values))(m2Lookups));
                    return allMatch;
                };
                throw new Error("Failed pattern match at Data.AdjacencyMap (line 113, column 1 - line 113, column 87): " + [ f.constructor.name, m1.constructor.name, m2.constructor.name ]);
            };
        };
    };
};
var showAdjacencyMap = function (dictShow) {
    return Data_Map_Internal.showMap(dictShow)(Data_Set.showSet(dictShow));
};
var reflexiveClosure = function (dictOrd) {
    return function (v) {
        return AM(Data_FunctorWithIndex.mapWithIndex(Data_Map_Internal.functorWithIndexMap)(function (k) {
            return Data_Set.insert(dictOrd)(k);
        })(v));
    };
};
var referredToVertexSet = function (dictOrd) {
    return function (m) {
        var xs = Control_Bind.bind(Control_Bind.bindArray)(Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray)(m))(function (v) {
            return Control_Bind.bind(Control_Bind.bindArray)(Data_Set.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.value1))(function (y) {
                return Control_Applicative.pure(Control_Applicative.applicativeArray)([ v.value0, y ]);
            });
        });
        return Data_Set.fromFoldable(Data_Foldable.foldableArray)(dictOrd)(Data_Array.concat(xs));
    };
};
var overlay = function (dictOrd) {
    return function (v) {
        return function (v1) {
            return AM(Data_Map_Internal.unionWith(dictOrd)(Data_Set.union(dictOrd))(v)(v1));
        };
    };
};
var newtypeAdjacencyMap = {
    Coercible0: function () {
        return undefined;
    }
};
var overlays = function (dictOrd) {
    var $162 = unionsWith(dictOrd)(Data_Foldable.foldableArray)(Data_Set.union(dictOrd));
    var $163 = Data_Functor.map(Data_Functor.functorArray)(Data_Newtype.unwrap());
    return function ($164) {
        return AM($162($163($164)));
    };
};
var preSet = function (dictOrd) {
    return function (x) {
        var p = function (v) {
            return Data_Set.member(dictOrd)(x)(v.value1);
        };
        var $165 = Data_Set.fromFoldable(Data_Foldable.foldableArray)(dictOrd);
        var $166 = Data_Functor.map(Data_Functor.functorArray)(Data_Tuple.fst);
        var $167 = Data_Array.filter(p);
        var $168 = Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray);
        var $169 = Data_Newtype.unwrap();
        return function ($170) {
            return $165($166($167($168($169($170)))));
        };
    };
};
var removeVertex = function (dictOrd) {
    return function (x) {
        var $171 = Data_Functor.map(Data_Map_Internal.functorMap)(Data_Set["delete"](dictOrd)(x));
        var $172 = Data_Map_Internal["delete"](dictOrd)(x);
        var $173 = Data_Newtype.unwrap();
        return function ($174) {
            return AM($171($172($173($174))));
        };
    };
};
var vertexArray = (function () {
    var $175 = Data_Set.toUnfoldable(Data_Unfoldable.unfoldableArray);
    var $176 = Data_Newtype.unwrap();
    return function ($177) {
        return $175(Data_Map.keys($176($177)));
    };
})();
var vertexCount = (function () {
    var $178 = Data_Newtype.unwrap();
    return function ($179) {
        return Data_Map_Internal.size($178($179));
    };
})();
var vertexSet = (function () {
    var $180 = Data_Newtype.unwrap();
    return function ($181) {
        return Data_Map.keys($180($181));
    };
})();
var maybeToArray = function (ma) {
    if (ma instanceof Data_Maybe.Nothing) {
        return [  ];
    };
    if (ma instanceof Data_Maybe.Just) {
        return [ ma.value0 ];
    };
    throw new Error("Failed pattern match at Data.AdjacencyMap (line 14, column 19 - line 16, column 18): " + [ ma.constructor.name ]);
};
var mapKeysWith = function (dictOrd) {
    return function (c) {
        return function (f) {
            var $182 = Data_Map_Internal.fromFoldableWith(dictOrd)(Data_Foldable.foldableArray)(c);
            var $183 = Data_FoldableWithIndex.foldrWithIndex(Data_Map_Internal.foldableWithIndexMap)(function (k) {
                return function (x) {
                    return function (xs) {
                        return Data_Array.cons(new Data_Tuple.Tuple(f(k), x))(xs);
                    };
                };
            })([  ]);
            return function ($184) {
                return $182($183($184));
            };
        };
    };
};
var mapFromSet = function (dictOrd) {
    return function (f) {
        return function (s) {
            var keys = Data_Set.toUnfoldable(Data_Unfoldable.unfoldableArray)(s);
            var values = Data_Functor.map(Data_Functor.functorArray)(f)(keys);
            return Data_Map_Internal.fromFoldable(dictOrd)(Data_Foldable.foldableArray)(Data_Array.zip(keys)(values));
        };
    };
};
var transpose = function (dictOrd) {
    return function (v) {
        var vs = mapFromSet(dictOrd)(Data_Function["const"](Data_Set.empty))(Data_Map.keys(v));
        var combine = function (v1) {
            return function (es) {
                return Data_Map_Internal.unionWith(dictOrd)(Data_Set.union(dictOrd))(mapFromSet(dictOrd)(Data_Function["const"](Data_Set.singleton(v1)))(es));
            };
        };
        return AM(Data_FoldableWithIndex.foldrWithIndex(Data_Map_Internal.foldableWithIndexMap)(combine)(vs)(v));
    };
};
var symmetricClosure = function (dictOrd) {
    return function (m) {
        return overlay(dictOrd)(m)(transpose(dictOrd)(m));
    };
};
var mapFromArray = function (dictOrd) {
    return Data_Map_Internal.fromFoldable(dictOrd)(Data_Foldable.foldableArray);
};
var mapAdjust = function (dictOrd) {
    return function (f) {
        return function (k) {
            return function (m) {
                var v = Data_Map_Internal.lookup(dictOrd)(k)(m);
                if (v instanceof Data_Maybe.Nothing) {
                    return m;
                };
                if (v instanceof Data_Maybe.Just) {
                    return Data_Map_Internal.insert(dictOrd)(k)(f(v.value0))(m);
                };
                throw new Error("Failed pattern match at Data.AdjacencyMap (line 32, column 19 - line 34, column 33): " + [ v.constructor.name ]);
            };
        };
    };
};
var removeEdge = function (dictOrd) {
    return function (x) {
        return function (y) {
            var $185 = mapAdjust(dictOrd)(Data_Set["delete"](dictOrd)(y))(x);
            var $186 = Data_Newtype.unwrap();
            return function ($187) {
                return AM($185($186($187)));
            };
        };
    };
};
var isSubmapOfBy = function (dictOrd) {
    return function (f) {
        return function (m1) {
            return function (m2) {
                return Data_Map_Internal.size(m1) <= Data_Map_Internal.size(m2) && submap$prime(dictOrd)(f)(m1)(m2);
            };
        };
    };
};
var isSubgraphOf = function (dictOrd) {
    return function (v) {
        return function (v1) {
            return isSubmapOfBy(dictOrd)(Data_Set.subset(dictOrd))(v)(v1);
        };
    };
};
var isEmpty = (function () {
    var $188 = Data_Newtype.unwrap();
    return function ($189) {
        return Data_Map_Internal.isEmpty($188($189));
    };
})();
var induce = function (dictOrd) {
    return function (p) {
        var $190 = Data_Functor.map(Data_Map_Internal.functorMap)(Data_Set.filter(dictOrd)(p));
        var $191 = Data_Map_Internal.filterWithKey(dictOrd)(function (k) {
            return function (v) {
                return p(k);
            };
        });
        var $192 = Data_Newtype.unwrap();
        return function ($193) {
            return AM($190($191($192($193))));
        };
    };
};
var hasVertex = function (dictOrd) {
    return function (x) {
        var $194 = Data_Map_Internal.member(dictOrd)(x);
        var $195 = Data_Newtype.unwrap();
        return function ($196) {
            return $194($195($196));
        };
    };
};
var hasEdge = function (dictOrd) {
    return function (u) {
        return function (v) {
            return function (v1) {
                var v3 = Data_Map_Internal.lookup(dictOrd)(u)(v1);
                if (v3 instanceof Data_Maybe.Nothing) {
                    return false;
                };
                if (v3 instanceof Data_Maybe.Just) {
                    return Data_Set.member(dictOrd)(v)(v3.value0);
                };
                throw new Error("Failed pattern match at Data.AdjacencyMap (line 137, column 22 - line 139, column 29): " + [ v3.constructor.name ]);
            };
        };
    };
};
var gmap = function (dictOrd) {
    return function (dictOrd1) {
        return function (f) {
            var $197 = Data_Functor.map(Data_Map_Internal.functorMap)(Data_Set.map(dictOrd1)(f));
            var $198 = mapKeysWith(dictOrd1)(Data_Set.union(dictOrd))(f);
            var $199 = Data_Newtype.unwrap();
            return function ($200) {
                return AM($197($198($199($200))));
            };
        };
    };
};
var mergeVertices = function (dictOrd) {
    return function (p) {
        return function (v) {
            return gmap(dictOrd)(dictOrd)(function (u) {
                var $112 = p(u);
                if ($112) {
                    return v;
                };
                return u;
            });
        };
    };
};
var replaceVertex = function (dictOrd) {
    return function (u) {
        return function (v) {
            return gmap(dictOrd)(dictOrd)(function (w) {
                var $113 = Data_Eq.eq(dictOrd.Eq0())(w)(u);
                if ($113) {
                    return v;
                };
                return w;
            });
        };
    };
};
var fromAdjacencySets = function (dictOrd) {
    return function (ss) {
        var vs = mapFromSet(dictOrd)(Data_Function["const"](Data_Set.empty))(Data_Set.unions(Data_Foldable.foldableArray)(dictOrd)(Data_Functor.map(Data_Functor.functorArray)(Data_Tuple.snd)(ss)));
        var es = Data_Map_Internal.fromFoldableWith(dictOrd)(Data_Foldable.foldableArray)(Data_Set.union(dictOrd))(ss);
        return AM(Data_Map_Internal.unionWith(dictOrd)(Data_Set.union(dictOrd))(vs)(es));
    };
};
var stars = function (dictOrd) {
    var $201 = fromAdjacencySets(dictOrd);
    var $202 = Data_Functor.map(Data_Functor.functorArray)(Data_Bifunctor.rmap(Data_Bifunctor.bifunctorTuple)(Data_Set.fromFoldable(Data_Foldable.foldableArray)(dictOrd)));
    return function ($203) {
        return $201($202($203));
    };
};
var foldfMaybeSet = function (dictOrd) {
    return function (v) {
        return function (acc) {
            if (v instanceof Data_Maybe.Nothing) {
                return acc;
            };
            if (v instanceof Data_Maybe.Just) {
                return Data_Set.insert(dictOrd)(v.value0)(acc);
            };
            throw new Error("Failed pattern match at Data.AdjacencyMap (line 42, column 1 - line 42, column 62): " + [ v.constructor.name, acc.constructor.name ]);
        };
    };
};
var foldfMaybeMap = function (dictOrd) {
    return function (v) {
        return function (v1) {
            return function (mka) {
                if (v instanceof Data_Maybe.Nothing) {
                    return mka;
                };
                if (v instanceof Data_Maybe.Just) {
                    return Data_Map_Internal.insert(dictOrd)(v.value0)(v1)(mka);
                };
                throw new Error("Failed pattern match at Data.AdjacencyMap (line 47, column 1 - line 47, column 73): " + [ v.constructor.name, v1.constructor.name, mka.constructor.name ]);
            };
        };
    };
};
var foldfMaybeHashMap = function (dictHashable) {
    return function (k) {
        return function (v) {
            return function (acc) {
                if (v instanceof Data_Maybe.Nothing) {
                    return acc;
                };
                if (v instanceof Data_Maybe.Just) {
                    return Data_HashMap.insert(dictHashable)(k)(v.value0)(acc);
                };
                throw new Error("Failed pattern match at Data.AdjacencyMap (line 55, column 1 - line 55, column 90): " + [ k.constructor.name, v.constructor.name, acc.constructor.name ]);
            };
        };
    };
};
var findWithDefault = function (dictOrd) {
    return function (a) {
        return function (b) {
            return function (m) {
                var v = Data_Map_Internal.lookup(dictOrd)(b)(m);
                if (v instanceof Data_Maybe.Nothing) {
                    return a;
                };
                if (v instanceof Data_Maybe.Just) {
                    return v.value0;
                };
                throw new Error("Failed pattern match at Data.AdjacencyMap (line 171, column 25 - line 173, column 14): " + [ v.constructor.name ]);
            };
        };
    };
};
var postSet = function (dictOrd) {
    return function (x) {
        var $204 = findWithDefault(dictOrd)(Data_Set.empty)(x);
        var $205 = Data_Newtype.unwrap();
        return function ($206) {
            return $204($205($206));
        };
    };
};
var eqAdjacencyMap = function (dictEq) {
    return Data_Map_Internal.eqMap(dictEq)(Data_Set.eqSet(dictEq));
};
var empty = Data_Map_Internal.empty;
var edges = function (dictOrd) {
    var $207 = fromAdjacencySets(dictOrd);
    var $208 = Data_Functor.map(Data_Functor.functorArray)(Data_Functor.map(Data_Tuple.functorTuple)(Data_Set.singleton));
    return function ($209) {
        return $207($208($209));
    };
};
var path = function (dictOrd) {
    return function (xs) {
        if (Data_Array.length(xs) <= 1) {
            var v = Data_Array.head(Data_Functor.map(Data_Functor.functorArray)(vertex)(xs));
            if (v instanceof Data_Maybe.Nothing) {
                return empty;
            };
            if (v instanceof Data_Maybe.Just) {
                return v.value0;
            };
            throw new Error("Failed pattern match at Data.AdjacencyMap (line 180, column 22 - line 182, column 16): " + [ v.constructor.name ]);
        };
        if (Data_Boolean.otherwise) {
            var v = Data_Array.tail(xs);
            if (v instanceof Data_Maybe.Nothing) {
                return empty;
            };
            if (v instanceof Data_Maybe.Just) {
                return edges(dictOrd)(Data_Array.zip(xs)(v.value0));
            };
            throw new Error("Failed pattern match at Data.AdjacencyMap (line 183, column 17 - line 185, column 33): " + [ v.constructor.name ]);
        };
        throw new Error("Failed pattern match at Data.AdjacencyMap (line 178, column 1 - line 178, column 53): " + [ xs.constructor.name ]);
    };
};
var edgeCount = (function () {
    var $210 = Data_Foldable.sum(Data_Map_Internal.foldableMap)(Data_Semiring.semiringInt);
    var $211 = Data_Functor.map(Data_Map_Internal.functorMap)(Data_Set.size);
    var $212 = Data_Newtype.unwrap();
    return function ($213) {
        return $210($211($212($213)));
    };
})();
var edgeArray = function (dictOrd) {
    return function (v) {
        return Control_Bind.bind(Control_Bind.bindArray)(Data_Array.sort(Data_Tuple.ordTuple(dictOrd)(Data_Set.ordSet(dictOrd)))(Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray)(v)))(function (v1) {
            return Control_Bind.bind(Control_Bind.bindArray)(Data_Array.sort(dictOrd)(Data_Set.toUnfoldable(Data_Unfoldable.unfoldableArray)(v1.value1)))(function (y) {
                return Control_Applicative.pure(Control_Applicative.applicativeArray)(new Data_Tuple.Tuple(v1.value0, y));
            });
        });
    };
};
var edgeSet = function (dictEq) {
    return function (dictOrd) {
        var $214 = Data_Set.fromFoldable(Data_Foldable.foldableArray)(Data_Tuple.ordTuple(dictOrd)(dictOrd));
        var $215 = edgeArray(dictOrd);
        return function ($216) {
            return $214($215($216));
        };
    };
};
var edge = function (dictOrd) {
    return function (x) {
        return function (y) {
            if (Data_Eq.eq(dictOrd.Eq0())(x)(y)) {
                return AM(Data_Map_Internal.singleton(x)(Data_Set.singleton(y)));
            };
            if (Data_Boolean.otherwise) {
                return AM(Data_Map_Internal.fromFoldable(dictOrd)(Data_Foldable.foldableArray)([ new Data_Tuple.Tuple(x, Data_Set.singleton(y)), new Data_Tuple.Tuple(y, Data_Set.empty) ]));
            };
            throw new Error("Failed pattern match at Data.AdjacencyMap (line 83, column 1 - line 83, column 52): " + [ x.constructor.name, y.constructor.name ]);
        };
    };
};
var consistent = function (dictOrd) {
    return function (v) {
        return Data_Set.subset(dictOrd)(referredToVertexSet(dictOrd)(v))(Data_Map.keys(v));
    };
};
var connect = function (dictOrd) {
    return function (v) {
        return function (v1) {
            return AM(unionsWith(dictOrd)(Data_Foldable.foldableArray)(Data_Set.union(dictOrd))([ v, v1, mapFromSet(dictOrd)(Data_Function["const"](Data_Map.keys(v1)))(Data_Map.keys(v)) ]));
        };
    };
};
var connects = function (dictOrd) {
    return Data_Foldable.foldr(Data_Foldable.foldableArray)(connect(dictOrd))(empty);
};
var compose = function (dictOrd) {
    return function (x) {
        return function (y) {
            var vs = Data_Set.union(dictOrd)(vertexSet(x))(vertexSet(y));
            var tx = transpose(dictOrd)(x);
            var arr = Control_Bind.bind(Control_Bind.bindArray)(Data_Set.toUnfoldable(Data_Unfoldable.unfoldableArray)(vs))(function (v) {
                var ys = postSet(dictOrd)(v)(y);
                return Control_Bind.discard(Control_Bind.discardUnit)(Control_Bind.bindArray)(Control_Alternative.guard(Control_Alternative.alternativeArray)(Data_Set.isEmpty(ys)))(function () {
                    return Control_Bind.bind(Control_Bind.bindArray)(Data_Set.toUnfoldable(Data_Unfoldable.unfoldableArray)(postSet(dictOrd)(v)(tx)))(function (t) {
                        return Control_Applicative.pure(Control_Applicative.applicativeArray)(new Data_Tuple.Tuple(t, ys));
                    });
                });
            });
            return fromAdjacencySets(dictOrd)(arr);
        };
    };
};
var genNew = function (dictOrd) {
    return function (old) {
        return overlay(dictOrd)(old)(compose(dictOrd)(old)(old));
    };
};
var transitiveClosure = function ($copy_dictOrd) {
    return function ($copy_old) {
        var $tco_var_dictOrd = $copy_dictOrd;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(dictOrd, old) {
            if (Data_Eq.eq(eqAdjacencyMap(dictOrd.Eq0()))(old)(genNew(dictOrd)(old))) {
                $tco_done = true;
                return old;
            };
            if (Data_Boolean.otherwise) {
                $tco_var_dictOrd = dictOrd;
                $copy_old = genNew(dictOrd)(old);
                return;
            };
            throw new Error("Failed pattern match at Data.AdjacencyMap (line 287, column 1 - line 287, column 73): " + [ old.constructor.name ]);
        };
        while (!$tco_done) {
            $tco_result = $tco_loop($tco_var_dictOrd, $copy_old);
        };
        return $tco_result;
    };
};
var closure = function (dictOrd) {
    var $217 = reflexiveClosure(dictOrd);
    var $218 = transitiveClosure(dictOrd);
    return function ($219) {
        return $217($218($219));
    };
};
var clique = function (dictOrd) {
    var go = function (as) {
        var v = Data_Array.uncons(as);
        if (v instanceof Data_Maybe.Nothing) {
            return new Data_Tuple.Tuple([  ], Data_Set.empty);
        };
        if (v instanceof Data_Maybe.Just) {
            var v1 = go(v.value0.tail);
            return new Data_Tuple.Tuple(Data_Array.cons(new Data_Tuple.Tuple(v.value0.head, v1.value1))(v1.value0), Data_Set.insert(dictOrd)(v.value0.head)(v1.value1));
        };
        throw new Error("Failed pattern match at Data.AdjacencyMap (line 200, column 11 - line 202, column 119): " + [ v.constructor.name ]);
    };
    var $220 = fromAdjacencySets(dictOrd);
    return function ($221) {
        return $220(Data_Tuple.fst(go($221)));
    };
};
var circuit = function (dictOrd) {
    return function (xs) {
        if (Data_Array["null"](xs)) {
            return empty;
        };
        if (Data_Boolean.otherwise) {
            var ys = Data_Maybe.maybe([  ])(Control_Category.identity(Control_Category.categoryFn))(Data_Array.tail(xs));
            var x = maybeToArray(Data_Array.head(xs));
            return path(dictOrd)(Data_Semigroup.append(Data_Semigroup.semigroupArray)(x)(Data_Semigroup.append(Data_Semigroup.semigroupArray)(ys)(x)));
        };
        throw new Error("Failed pattern match at Data.AdjacencyMap (line 187, column 1 - line 187, column 56): " + [ xs.constructor.name ]);
    };
};
var catMaybeSet = function (dictOrd) {
    return function (sma) {
        return Data_Foldable.foldr(Data_Set.foldableSet)(foldfMaybeSet(dictOrd))(Data_Set.empty)(sma);
    };
};
var catMaybeMap = function (dictOrd) {
    return function (mmka) {
        return Data_FoldableWithIndex.foldrWithIndex(Data_Map_Internal.foldableWithIndexMap)(foldfMaybeMap(dictOrd))(Data_Map_Internal.empty)(mmka);
    };
};
var induceJust = function (dictOrd) {
    var $222 = Data_Functor.map(Data_Map_Internal.functorMap)(catMaybeSet(dictOrd));
    var $223 = catMaybeMap(dictOrd);
    var $224 = Data_Newtype.unwrap();
    return function ($225) {
        return AM($222($223($224($225))));
    };
};
var catMaybeHashMap = function (dictHashable) {
    return function (hkma) {
        return Data_FoldableWithIndex.foldrWithIndex(Data_HashMap.foldableWithIndexHashMap)(foldfMaybeHashMap(dictHashable))(Data_HashMap.empty)(hkma);
    };
};
var box = function (dictOrd) {
    return function (dictOrd1) {
        return function (v) {
            return function (v1) {
                var ys = Control_Bind.bind(Control_Bind.bindArray)(Data_Set.toUnfoldable(Data_Unfoldable.unfoldableArray)(Data_Map.keys(v)))(function (a) {
                    return Control_Bind.bind(Control_Bind.bindArray)(Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray)(v1))(function (v2) {
                        return Control_Applicative.pure(Control_Applicative.applicativeArray)(new Data_Tuple.Tuple(new Data_Tuple.Tuple(a, v2.value0), Data_Set.map(Data_Tuple.ordTuple(dictOrd)(dictOrd1))(Data_Tuple.Tuple.create(a))(v2.value1)));
                    });
                });
                var xs = Control_Bind.bind(Control_Bind.bindArray)(Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray)(v))(function (v2) {
                    return Control_Bind.bind(Control_Bind.bindArray)(Data_Set.toUnfoldable(Data_Unfoldable.unfoldableArray)(Data_Map.keys(v1)))(function (b) {
                        return Control_Applicative.pure(Control_Applicative.applicativeArray)(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v2.value0, b), Data_Set.map(Data_Tuple.ordTuple(dictOrd)(dictOrd1))(Data_Function.flip(Data_Tuple.Tuple.create)(b))(v2.value1)));
                    });
                });
                return overlay(Data_Tuple.ordTuple(dictOrd)(dictOrd1))(AM(mapFromArray(Data_Tuple.ordTuple(dictOrd)(dictOrd1))(xs)))(AM(mapFromArray(Data_Tuple.ordTuple(dictOrd)(dictOrd1))(ys)));
            };
        };
    };
};
var biclique = function (dictOrd) {
    return function (xs) {
        return function (ys) {
            var y = Data_Set.fromFoldable(Data_Foldable.foldableArray)(dictOrd)(ys);
            var x = Data_Set.fromFoldable(Data_Foldable.foldableArray)(dictOrd)(xs);
            var adjacent = function (v) {
                var $158 = Data_Set.member(dictOrd)(v)(x);
                if ($158) {
                    return y;
                };
                return Data_Set.empty;
            };
            return AM(mapFromSet(dictOrd)(adjacent)(Data_Set.union(dictOrd)(x)(y)));
        };
    };
};
var adjacencyArray = function (dictOrd) {
    var $226 = Data_Functor.map(Data_Functor.functorArray)(Data_Functor.map(Data_Tuple.functorTuple)((function () {
        var $231 = Data_Array.sort(dictOrd);
        var $232 = Data_Set.toUnfoldable(Data_Unfoldable.unfoldableArray);
        return function ($233) {
            return $231($232($233));
        };
    })()));
    var $227 = Data_Array.sort(Data_Tuple.ordTuple(dictOrd)(Data_Set.ordSet(dictOrd)));
    var $228 = Data_Map_Internal.toUnfoldable(Data_Unfoldable.unfoldableArray);
    var $229 = Data_Newtype.unwrap();
    return function ($230) {
        return $226($227($228($229($230))));
    };
};
module.exports = {
    maybeToArray: maybeToArray,
    unionsWith: unionsWith,
    mapFromSet: mapFromSet,
    isSubmapOfBy: isSubmapOfBy,
    mapAdjust: mapAdjust,
    mapKeysWith: mapKeysWith,
    catMaybeSet: catMaybeSet,
    foldfMaybeSet: foldfMaybeSet,
    foldfMaybeMap: foldfMaybeMap,
    catMaybeMap: catMaybeMap,
    foldfMaybeHashMap: foldfMaybeHashMap,
    catMaybeHashMap: catMaybeHashMap,
    mapFromArray: mapFromArray,
    AM: AM,
    empty: empty,
    vertex: vertex,
    edge: edge,
    overlay: overlay,
    connect: connect,
    vertices: vertices,
    edges: edges,
    overlays: overlays,
    connects: connects,
    "submap'": submap$prime,
    isSubgraphOf: isSubgraphOf,
    isEmpty: isEmpty,
    hasVertex: hasVertex,
    hasEdge: hasEdge,
    vertexCount: vertexCount,
    edgeCount: edgeCount,
    vertexArray: vertexArray,
    edgeArray: edgeArray,
    vertexSet: vertexSet,
    edgeSet: edgeSet,
    adjacencyArray: adjacencyArray,
    preSet: preSet,
    findWithDefault: findWithDefault,
    postSet: postSet,
    path: path,
    circuit: circuit,
    clique: clique,
    biclique: biclique,
    stars: stars,
    fromAdjacencySets: fromAdjacencySets,
    removeVertex: removeVertex,
    removeEdge: removeEdge,
    gmap: gmap,
    replaceVertex: replaceVertex,
    mergeVertices: mergeVertices,
    transpose: transpose,
    induce: induce,
    induceJust: induceJust,
    compose: compose,
    box: box,
    reflexiveClosure: reflexiveClosure,
    symmetricClosure: symmetricClosure,
    transitiveClosure: transitiveClosure,
    genNew: genNew,
    closure: closure,
    consistent: consistent,
    referredToVertexSet: referredToVertexSet,
    newtypeAdjacencyMap: newtypeAdjacencyMap,
    eqAdjacencyMap: eqAdjacencyMap,
    showAdjacencyMap: showAdjacencyMap
};
