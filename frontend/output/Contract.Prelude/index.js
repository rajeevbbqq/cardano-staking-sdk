// Generated by purs version 0.14.5
"use strict";
var Data_Either = require("../Data.Either/index.js");
var Data_Enum = require("../Data.Enum/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Generic_Rep = require("../Data.Generic.Rep/index.js");
var Data_Log_Level = require("../Data.Log.Level/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Newtype = require("../Data.Newtype/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Show_Generic = require("../Data.Show.Generic/index.js");
var Data_Traversable = require("../Data.Traversable/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Tuple_Nested = require("../Data.Tuple.Nested/index.js");
var Effect = require("../Effect/index.js");
var Effect_Aff = require("../Effect.Aff/index.js");
var Effect_Aff_Class = require("../Effect.Aff.Class/index.js");
var Effect_Class = require("../Effect.Class/index.js");
var Effect_Class_Console = require("../Effect.Class.Console/index.js");
var Helpers = require("../Helpers/index.js");
var Prelude = require("../Prelude/index.js");
var Undefined = require("../Undefined/index.js");
var mconcat = function (dictFoldable) {
    return function (dictMonoid) {
        return Data_Foldable.foldr(dictFoldable)(Data_Semigroup.append(dictMonoid.Semigroup0()))(Data_Monoid.mempty(dictMonoid));
    };
};
module.exports = {
    mconcat: mconcat,
    Left: Data_Either.Left,
    Right: Data_Either.Right,
    choose: Data_Either.choose,
    either: Data_Either.either,
    fromLeft: Data_Either.fromLeft,
    "fromLeft'": Data_Either["fromLeft'"],
    fromRight: Data_Either.fromRight,
    "fromRight'": Data_Either["fromRight'"],
    hush: Data_Either.hush,
    isLeft: Data_Either.isLeft,
    isRight: Data_Either.isRight,
    note: Data_Either.note,
    "note'": Data_Either["note'"],
    Cardinality: Data_Enum.Cardinality,
    cardinality: Data_Enum.cardinality,
    defaultCardinality: Data_Enum.defaultCardinality,
    defaultFromEnum: Data_Enum.defaultFromEnum,
    defaultPred: Data_Enum.defaultPred,
    defaultSucc: Data_Enum.defaultSucc,
    defaultToEnum: Data_Enum.defaultToEnum,
    downFrom: Data_Enum.downFrom,
    downFromIncluding: Data_Enum.downFromIncluding,
    enumFromThenTo: Data_Enum.enumFromThenTo,
    enumFromTo: Data_Enum.enumFromTo,
    fromEnum: Data_Enum.fromEnum,
    pred: Data_Enum.pred,
    succ: Data_Enum.succ,
    toEnum: Data_Enum.toEnum,
    toEnumWithDefaults: Data_Enum.toEnumWithDefaults,
    upFrom: Data_Enum.upFrom,
    upFromIncluding: Data_Enum.upFromIncluding,
    all: Data_Foldable.all,
    and: Data_Foldable.and,
    any: Data_Foldable.any,
    elem: Data_Foldable.elem,
    find: Data_Foldable.find,
    findMap: Data_Foldable.findMap,
    fold: Data_Foldable.fold,
    foldM: Data_Foldable.foldM,
    foldMap: Data_Foldable.foldMap,
    foldMapDefaultL: Data_Foldable.foldMapDefaultL,
    foldMapDefaultR: Data_Foldable.foldMapDefaultR,
    foldl: Data_Foldable.foldl,
    foldlDefault: Data_Foldable.foldlDefault,
    foldr: Data_Foldable.foldr,
    foldrDefault: Data_Foldable.foldrDefault,
    indexl: Data_Foldable.indexl,
    indexr: Data_Foldable.indexr,
    intercalate: Data_Foldable.intercalate,
    length: Data_Foldable.length,
    lookup: Data_Foldable.lookup,
    maximum: Data_Foldable.maximum,
    maximumBy: Data_Foldable.maximumBy,
    minimum: Data_Foldable.minimum,
    minimumBy: Data_Foldable.minimumBy,
    notElem: Data_Foldable.notElem,
    "null": Data_Foldable["null"],
    oneOf: Data_Foldable.oneOf,
    oneOfMap: Data_Foldable.oneOfMap,
    or: Data_Foldable.or,
    product: Data_Foldable.product,
    sum: Data_Foldable.sum,
    surround: Data_Foldable.surround,
    surroundMap: Data_Foldable.surroundMap,
    Debug: Data_Log_Level.Debug,
    "Error": Data_Log_Level["Error"],
    Info: Data_Log_Level.Info,
    Trace: Data_Log_Level.Trace,
    Warn: Data_Log_Level.Warn,
    Just: Data_Maybe.Just,
    Nothing: Data_Maybe.Nothing,
    fromJust: Data_Maybe.fromJust,
    fromMaybe: Data_Maybe.fromMaybe,
    "fromMaybe'": Data_Maybe["fromMaybe'"],
    isJust: Data_Maybe.isJust,
    isNothing: Data_Maybe.isNothing,
    maybe: Data_Maybe.maybe,
    "maybe'": Data_Maybe["maybe'"],
    optional: Data_Maybe.optional,
    over: Data_Newtype.over,
    unwrap: Data_Newtype.unwrap,
    wrap: Data_Newtype.wrap,
    genericShow: Data_Show_Generic.genericShow,
    "for": Data_Traversable["for"],
    for_: Data_Traversable.for_,
    mapAccumL: Data_Traversable.mapAccumL,
    mapAccumR: Data_Traversable.mapAccumR,
    scanl: Data_Traversable.scanl,
    scanr: Data_Traversable.scanr,
    sequence: Data_Traversable.sequence,
    sequenceDefault: Data_Traversable.sequenceDefault,
    sequence_: Data_Traversable.sequence_,
    traverse: Data_Traversable.traverse,
    traverseDefault: Data_Traversable.traverseDefault,
    traverse_: Data_Traversable.traverse_,
    Tuple: Data_Tuple.Tuple,
    curry: Data_Tuple.curry,
    fst: Data_Tuple.fst,
    snd: Data_Tuple.snd,
    swap: Data_Tuple.swap,
    uncurry: Data_Tuple.uncurry,
    curry1: Data_Tuple_Nested.curry1,
    curry10: Data_Tuple_Nested.curry10,
    curry2: Data_Tuple_Nested.curry2,
    curry3: Data_Tuple_Nested.curry3,
    curry4: Data_Tuple_Nested.curry4,
    curry5: Data_Tuple_Nested.curry5,
    curry6: Data_Tuple_Nested.curry6,
    curry7: Data_Tuple_Nested.curry7,
    curry8: Data_Tuple_Nested.curry8,
    curry9: Data_Tuple_Nested.curry9,
    get1: Data_Tuple_Nested.get1,
    get10: Data_Tuple_Nested.get10,
    get2: Data_Tuple_Nested.get2,
    get3: Data_Tuple_Nested.get3,
    get4: Data_Tuple_Nested.get4,
    get5: Data_Tuple_Nested.get5,
    get6: Data_Tuple_Nested.get6,
    get7: Data_Tuple_Nested.get7,
    get8: Data_Tuple_Nested.get8,
    get9: Data_Tuple_Nested.get9,
    over1: Data_Tuple_Nested.over1,
    over10: Data_Tuple_Nested.over10,
    over2: Data_Tuple_Nested.over2,
    over3: Data_Tuple_Nested.over3,
    over4: Data_Tuple_Nested.over4,
    over5: Data_Tuple_Nested.over5,
    over6: Data_Tuple_Nested.over6,
    over7: Data_Tuple_Nested.over7,
    over8: Data_Tuple_Nested.over8,
    over9: Data_Tuple_Nested.over9,
    tuple1: Data_Tuple_Nested.tuple1,
    tuple10: Data_Tuple_Nested.tuple10,
    tuple2: Data_Tuple_Nested.tuple2,
    tuple3: Data_Tuple_Nested.tuple3,
    tuple4: Data_Tuple_Nested.tuple4,
    tuple5: Data_Tuple_Nested.tuple5,
    tuple6: Data_Tuple_Nested.tuple6,
    tuple7: Data_Tuple_Nested.tuple7,
    tuple8: Data_Tuple_Nested.tuple8,
    tuple9: Data_Tuple_Nested.tuple9,
    uncurry1: Data_Tuple_Nested.uncurry1,
    uncurry10: Data_Tuple_Nested.uncurry10,
    uncurry2: Data_Tuple_Nested.uncurry2,
    uncurry3: Data_Tuple_Nested.uncurry3,
    uncurry4: Data_Tuple_Nested.uncurry4,
    uncurry5: Data_Tuple_Nested.uncurry5,
    uncurry6: Data_Tuple_Nested.uncurry6,
    uncurry7: Data_Tuple_Nested.uncurry7,
    uncurry8: Data_Tuple_Nested.uncurry8,
    uncurry9: Data_Tuple_Nested.uncurry9,
    liftAff: Effect_Aff_Class.liftAff,
    liftEffect: Effect_Class.liftEffect,
    log: Effect_Class_Console.log,
    appendFirstMaybe: Helpers.appendFirstMaybe,
    appendLastMaybe: Helpers.appendLastMaybe,
    filterMapM: Helpers.filterMapM,
    filterMapWithKeyM: Helpers.filterMapWithKeyM,
    fromJustEff: Helpers.fromJustEff,
    fromRightEff: Helpers.fromRightEff,
    liftEither: Helpers.liftEither,
    liftM: Helpers.liftM,
    liftMWith: Helpers.liftMWith,
    EQ: Prelude.EQ,
    GT: Prelude.GT,
    LT: Prelude.LT,
    absurd: Prelude.absurd,
    add: Prelude.add,
    ap: Prelude.ap,
    append: Prelude.append,
    apply: Prelude.apply,
    between: Prelude.between,
    bind: Prelude.bind,
    bottom: Prelude.bottom,
    clamp: Prelude.clamp,
    compare: Prelude.compare,
    comparing: Prelude.comparing,
    compose: Prelude.compose,
    conj: Prelude.conj,
    "const": Prelude["const"],
    degree: Prelude.degree,
    discard: Prelude.discard,
    disj: Prelude.disj,
    div: Prelude.div,
    eq: Prelude.eq,
    flap: Prelude.flap,
    flip: Prelude.flip,
    gcd: Prelude.gcd,
    identity: Prelude.identity,
    ifM: Prelude.ifM,
    join: Prelude.join,
    lcm: Prelude.lcm,
    liftA1: Prelude.liftA1,
    liftM1: Prelude.liftM1,
    map: Prelude.map,
    max: Prelude.max,
    mempty: Prelude.mempty,
    min: Prelude.min,
    mod: Prelude.mod,
    mul: Prelude.mul,
    negate: Prelude.negate,
    not: Prelude.not,
    notEq: Prelude.notEq,
    one: Prelude.one,
    otherwise: Prelude.otherwise,
    pure: Prelude.pure,
    recip: Prelude.recip,
    show: Prelude.show,
    sub: Prelude.sub,
    top: Prelude.top,
    unit: Prelude.unit,
    unless: Prelude.unless,
    unlessM: Prelude.unlessM,
    "void": Prelude["void"],
    when: Prelude.when,
    whenM: Prelude.whenM,
    zero: Prelude.zero,
    "undefined": Undefined["undefined"]
};
