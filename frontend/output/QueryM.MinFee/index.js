// Generated by purs version 0.14.5
"use strict";
var Cardano_Types_Transaction = require("../Cardano.Types.Transaction/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Lens_Getter = require("../Data.Lens.Getter/index.js");
var Data_Lens_Internal_Forget = require("../Data.Lens.Internal.Forget/index.js");
var Data_Map_Internal = require("../Data.Map.Internal/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Newtype = require("../Data.Newtype/index.js");
var Data_Set = require("../Data.Set/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_Traversable = require("../Data.Traversable/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Effect_Aff = require("../Effect.Aff/index.js");
var Effect_Exception = require("../Effect.Exception/index.js");
var Helpers = require("../Helpers/index.js");
var QueryM = require("../QueryM/index.js");
var QueryM_ProtocolParameters = require("../QueryM.ProtocolParameters/index.js");
var QueryM_Utxos = require("../QueryM.Utxos/index.js");
var Serialization_Address = require("../Serialization.Address/index.js");
var Serialization_Hash = require("../Serialization.Hash/index.js");
var Serialization_MinFee = require("../Serialization.MinFee/index.js");
var Types_Transaction = require("../Types.Transaction/index.js");
var getSelfSigners = function (tx) {
    var toUtxoMap = (function () {
        var $15 = Data_Map_Internal.fromFoldable(Types_Transaction.ordTransactionInput)(Data_Foldable.foldableArray);
        var $16 = Data_Functor.map(Data_Functor.functorArray)((function () {
            var $18 = Data_Newtype.unwrap();
            return function ($19) {
                return (function (v) {
                    return new Data_Tuple.Tuple(v.input, v.output);
                })($18($19));
            };
        })());
        return function ($17) {
            return $15($16($17));
        };
    })();
    var setFor = function (dictMonad) {
        return function (dictOrd) {
            return function (dictOrd1) {
                return function (txIns) {
                    return function (f) {
                        return Data_Functor.map(((dictMonad.Bind1()).Apply0()).Functor0())(Data_Set.fromFoldable(Data_Foldable.foldableArray)(dictOrd1))(Data_Traversable["for"](dictMonad.Applicative0())(Data_Traversable.traversableArray)(Data_Array.fromFoldable(Data_Set.foldableSet)(txIns))(f));
                    };
                };
            };
        };
    };
    var txInputs = Data_Lens_Getter.viewOn(tx)((function () {
        var $20 = Cardano_Types_Transaction["_body"](Data_Lens_Internal_Forget.strongForget);
        var $21 = Cardano_Types_Transaction["_inputs"](Data_Lens_Internal_Forget.strongForget);
        return function ($22) {
            return $20($21($22));
        };
    })());
    return Control_Bind.bind(QueryM.bindQueryMExtended(Effect_Aff.bindAff))(setFor(QueryM.monadQueryMExtendedAff)(Types_Transaction.ordTransactionInput)(Serialization_Address.ordAddress)(txInputs)(function (txInput) {
        return Helpers.liftedM(QueryM.monadErrorErrorQueryMExte)(Effect_Exception.error("Couldn't get tx output for " + Data_Show.show(Types_Transaction.showTransactionInput)(txInput)))(Data_Functor.map(QueryM.functorQueryMExtended(Effect_Aff.functorAff))(Data_Functor.map(Data_Maybe.functorMaybe)((function () {
            var $23 = Data_Newtype.unwrap();
            return function ($24) {
                return (function (v) {
                    return v.address;
                })($23($24));
            };
        })()))(QueryM_Utxos.getUtxo(txInput)));
    }))(function (v) {
        var txCollats = Data_Set.fromFoldable(Data_Foldable.foldableArray)(Types_Transaction.ordTransactionInput)(Data_Maybe.fromMaybe([  ])(Data_Lens_Getter.viewOn(tx)((function () {
            var $25 = Cardano_Types_Transaction["_body"](Data_Lens_Internal_Forget.strongForget);
            var $26 = Cardano_Types_Transaction["_collateral"](Data_Lens_Internal_Forget.strongForget);
            return function ($27) {
                return $25($26($27));
            };
        })())));
        return Control_Bind.bind(QueryM.bindQueryMExtended(Effect_Aff.bindAff))(Data_Functor.map(QueryM.functorQueryMExtended(Effect_Aff.functorAff))(Data_Maybe.maybe(Data_Map_Internal.empty)(toUtxoMap))(QueryM_Utxos.getWalletCollateral))(function (walletCollats) {
            return Control_Bind.bind(QueryM.bindQueryMExtended(Effect_Aff.bindAff))(setFor(QueryM.monadQueryMExtendedAff)(Types_Transaction.ordTransactionInput)(Serialization_Address.ordAddress)(txCollats)(function (txCollat) {
                return Helpers.liftM(QueryM.monadErrorErrorQueryMExte)(Effect_Exception.error("Couldn't get tx output for " + Data_Show.show(Types_Transaction.showTransactionInput)(txCollat)))(Data_Functor.map(Data_Maybe.functorMaybe)((function () {
                    var $28 = Data_Newtype.unwrap();
                    return function ($29) {
                        return (function (v1) {
                            return v1.address;
                        })($28($29));
                    };
                })())(Data_Map_Internal.lookup(Types_Transaction.ordTransactionInput)(txCollat)(walletCollats)));
            }))(function (v1) {
                return Control_Bind.bind(QueryM.bindQueryMExtended(Effect_Aff.bindAff))(Data_Functor.map(QueryM.functorQueryMExtended(Effect_Aff.functorAff))(Data_Set.fromFoldable(Data_Foldable.foldableArray)(Serialization_Address.ordAddress))(Helpers.liftedM(QueryM.monadErrorErrorQueryMExte)(Effect_Exception.error("Could not get own addresses"))(QueryM.getWalletAddresses)))(function (v2) {
                    var txOwnAddrs = Data_Set.intersection(Serialization_Address.ordAddress)(v2)(Data_Set.union(Serialization_Address.ordAddress)(v)(v1));
                    return setFor(QueryM.monadQueryMExtendedAff)(Serialization_Address.ordAddress)(Serialization_Hash.ordEd25519KeyHash)(txOwnAddrs)((function () {
                        var $30 = Helpers.liftM(QueryM.monadErrorErrorQueryMExte)(Effect_Exception.error("Could not convert address to key hash"));
                        var $31 = Control_Bind.composeKleisli(Data_Maybe.bindMaybe)(Serialization_Address.addressPaymentCred)(Serialization_Address.stakeCredentialToKeyHash);
                        return function ($32) {
                            return $30($31($32));
                        };
                    })());
                });
            });
        });
    });
};
var calculateMinFee = function (tx) {
    return Control_Bind.bind(QueryM.bindQueryMExtended(Effect_Aff.bindAff))(getSelfSigners(tx))(function (selfSigners) {
        return Control_Bind.bind(QueryM.bindQueryMExtended(Effect_Aff.bindAff))(QueryM_ProtocolParameters.getProtocolParameters)(function (pparams) {
            return Serialization_MinFee.calculateMinFeeCsl(QueryM.monadEffectQueryMExtended)(QueryM.monadThrowErrorQueryMExte)(pparams)(selfSigners)(tx);
        });
    });
};
module.exports = {
    calculateMinFee: calculateMinFee
};
