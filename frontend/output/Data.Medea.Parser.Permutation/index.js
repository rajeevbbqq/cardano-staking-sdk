// Generated by purs version 0.14.5
"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Control_Plus = require("../Control.Plus/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var P = (function () {
    function P(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    P.create = function (value0) {
        return function (value1) {
            return new P(value0, value1);
        };
    };
    return P;
})();
var runPermutation = function (dictAlternative) {
    return function (dictMonad) {
        return function (v) {
            var f = function (v1) {
                if (v1 instanceof Data_Maybe.Nothing) {
                    return Data_Maybe.maybe(Control_Plus.empty(dictAlternative.Plus1()))(Control_Applicative.pure(dictAlternative.Applicative0()))(v.value0);
                };
                if (v1 instanceof Data_Maybe.Just) {
                    return runPermutation(dictAlternative)(dictMonad)(v1.value0);
                };
                throw new Error("Failed pattern match at Data.Medea.Parser.Permutation (line 25, column 3 - line 25, column 37): " + [ v1.constructor.name ]);
            };
            return Control_Bind.bind(dictMonad.Bind1())(Data_Maybe.optional((dictAlternative.Plus1()).Alt0())(dictAlternative.Applicative0())(v.value1))(f);
        };
    };
};
var functorPermutation = function (dictFunctor) {
    return {
        map: function (f) {
            return function (v) {
                return new P(Data_Functor.map(Data_Maybe.functorMaybe)(f)(v.value0), Data_Functor.map(dictFunctor)(Data_Functor.map(functorPermutation(dictFunctor))(f))(v.value1));
            };
        }
    };
};
var applyPermutation = function (dictAlternative) {
    return {
        apply: function (v) {
            return function (v1) {
                var rhsAlt = Data_Functor.map(((dictAlternative.Plus1()).Alt0()).Functor0())(function (v3) {
                    return Control_Apply.apply(applyPermutation(dictAlternative))(v)(v3);
                })(v1.value1);
                var lhsAlt = Data_Functor.map(((dictAlternative.Plus1()).Alt0()).Functor0())(function (v3) {
                    return Control_Apply.apply(applyPermutation(dictAlternative))(v3)(v1);
                })(v.value1);
                return new P(Control_Apply.apply(Data_Maybe.applyMaybe)(v.value0)(v1.value0), Control_Alt.alt((dictAlternative.Plus1()).Alt0())(lhsAlt)(rhsAlt));
            };
        },
        Functor0: function () {
            return functorPermutation(((dictAlternative.Plus1()).Alt0()).Functor0());
        }
    };
};
var applicativePermutation = function (dictAlternative) {
    return {
        pure: function (value) {
            return new P(new Data_Maybe.Just(value), Control_Plus.empty(dictAlternative.Plus1()));
        },
        Apply0: function () {
            return applyPermutation(dictAlternative);
        }
    };
};
var toPermutationWithDefault = function (dictAlternative) {
    return function (v) {
        return function (p) {
            return P.create(new Data_Maybe.Just(v))(Data_Functor.map(((dictAlternative.Plus1()).Alt0()).Functor0())(Control_Applicative.pure(applicativePermutation(dictAlternative)))(p));
        };
    };
};
module.exports = {
    P: P,
    runPermutation: runPermutation,
    toPermutationWithDefault: toPermutationWithDefault,
    functorPermutation: functorPermutation,
    applyPermutation: applyPermutation,
    applicativePermutation: applicativePermutation
};
