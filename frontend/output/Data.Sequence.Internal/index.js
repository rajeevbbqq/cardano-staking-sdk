// Generated by purs version 0.14.5
"use strict";
var Data_Eq = require("../Data.Eq/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Lazy = require("../Data.Lazy/index.js");
var Data_Monoid = require("../Data.Monoid/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ordering = require("../Data.Ordering/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Show = require("../Data.Show/index.js");
var Unsafe_Coerce = require("../Unsafe.Coerce/index.js");
var NoKey = (function () {
    function NoKey() {

    };
    NoKey.value = new NoKey();
    return NoKey;
})();
var Key = (function () {
    function Key(value0) {
        this.value0 = value0;
    };
    Key.create = function (value0) {
        return new Key(value0);
    };
    return Key;
})();
var Elem = function (x) {
    return x;
};
var strJoin = function (dictShow) {
    return function (glue) {
        var $73 = Data_Foldable.intercalate(Data_Foldable.foldableArray)(Data_Monoid.monoidString)(glue);
        var $74 = Data_Functor.map(Data_Functor.functorArray)(Data_Show.show(dictShow));
        return function ($75) {
            return $73($74($75));
        };
    };
};
var showKey = function (dictShow) {
    return {
        show: function (v) {
            if (v instanceof Key) {
                return "(Key " + (Data_Show.show(dictShow)(v.value0) + ")");
            };
            if (v instanceof NoKey) {
                return "NoKey";
            };
            throw new Error("Failed pattern match at Data.Sequence.Internal (line 106, column 1 - line 108, column 23): " + [ v.constructor.name ]);
        }
    };
};
var semigroupKey = {
    append: function (v) {
        return function (v1) {
            if (v1 instanceof NoKey) {
                return v;
            };
            return v1;
        };
    }
};
var monoidKey = {
    mempty: NoKey.value,
    Semigroup0: function () {
        return semigroupKey;
    }
};
var measuredElemKey = {
    measure: function (v) {
        return new Key(v);
    }
};
var measuredElem = {
    measure: function (v) {
        return 1;
    }
};
var measure = function (dict) {
    return dict.measure;
};
var measuredArray = function (dictMonoid) {
    return function (dictMeasured) {
        return {
            measure: function (xs) {
                return Data_Foldable.foldl(Data_Foldable.foldableArray)(function (i) {
                    return function (a) {
                        return Data_Semigroup.append(dictMonoid.Semigroup0())(i)(measure(dictMeasured)(a));
                    };
                })(Data_Monoid.mempty(dictMonoid))(xs);
            }
        };
    };
};
var measuredLazy = function (dictMonoid) {
    return function (dictMeasured) {
        return {
            measure: function (s) {
                return measure(dictMeasured)(Data_Lazy.force(s));
            }
        };
    };
};
var mapmap = function (dictFunctor) {
    return function (dictFunctor1) {
        var $76 = Data_Functor.map(dictFunctor);
        var $77 = Data_Functor.map(dictFunctor1);
        return function ($78) {
            return $76($77($78));
        };
    };
};
var mapmapmap = function (dictFunctor) {
    return function (dictFunctor1) {
        return function (dictFunctor2) {
            var $79 = mapmap(dictFunctor)(dictFunctor1);
            var $80 = Data_Functor.map(dictFunctor2);
            return function ($81) {
                return $79($80($81));
            };
        };
    };
};
var mapGetElem = function (dictFunctor) {
    return Unsafe_Coerce.unsafeCoerce;
};
var mapElem = function (dictFunctor) {
    return Unsafe_Coerce.unsafeCoerce;
};
var liftElem = Unsafe_Coerce.unsafeCoerce;
var lift2Elem = Unsafe_Coerce.unsafeCoerce;
var getElem = function (v) {
    return v;
};
var showElem = function (dictShow) {
    return {
        show: function (x) {
            return "Elem (" + (Data_Show.show(dictShow)(getElem(x)) + ")");
        }
    };
};
var functorElem = {
    map: function (f) {
        return function (v) {
            return f(v);
        };
    }
};
var foldableElem = {
    foldr: function (f) {
        return function (z) {
            return function (v) {
                return f(v)(z);
            };
        };
    },
    foldl: function (f) {
        return function (z) {
            return function (v) {
                return f(z)(v);
            };
        };
    },
    foldMap: function (dictMonoid) {
        return function (f) {
            return function (v) {
                return f(v);
            };
        };
    }
};
var traversableElem = {
    traverse: function (dictApplicative) {
        return function (f) {
            return function (v) {
                return mapElem((dictApplicative.Apply0()).Functor0())(f(v));
            };
        };
    },
    sequence: function (dictApplicative) {
        return function (v) {
            return mapElem((dictApplicative.Apply0()).Functor0())(v);
        };
    },
    Functor0: function () {
        return functorElem;
    },
    Foldable1: function () {
        return foldableElem;
    }
};
var eqKey = function (dictEq) {
    return {
        eq: function (v) {
            return function (v1) {
                if (v instanceof Key && v1 instanceof Key) {
                    return Data_Eq.eq(dictEq)(v.value0)(v1.value0);
                };
                if (v instanceof NoKey && v1 instanceof NoKey) {
                    return true;
                };
                return false;
            };
        }
    };
};
var ordKey = function (dictOrd) {
    return {
        compare: function (v) {
            return function (v1) {
                if (v instanceof NoKey) {
                    return Data_Ordering.LT.value;
                };
                if (v1 instanceof NoKey) {
                    return Data_Ordering.GT.value;
                };
                if (v instanceof Key && v1 instanceof Key) {
                    return Data_Ord.compare(dictOrd)(v.value0)(v1.value0);
                };
                throw new Error("Failed pattern match at Data.Sequence.Internal (line 114, column 1 - line 117, column 40): " + [ v.constructor.name, v1.constructor.name ]);
            };
        },
        Eq0: function () {
            return eqKey(dictOrd.Eq0());
        }
    };
};
var eqElem = function (dictEq) {
    return {
        eq: function (v) {
            return function (v1) {
                return Data_Eq.eq(dictEq)(v)(v1);
            };
        }
    };
};
var ordElem = function (dictOrd) {
    return {
        compare: function (v) {
            return function (v1) {
                return Data_Ord.compare(dictOrd)(v)(v1);
            };
        },
        Eq0: function () {
            return eqElem(dictOrd.Eq0());
        }
    };
};
module.exports = {
    mapmap: mapmap,
    mapmapmap: mapmapmap,
    strJoin: strJoin,
    measure: measure,
    Elem: Elem,
    getElem: getElem,
    mapElem: mapElem,
    mapGetElem: mapGetElem,
    lift2Elem: lift2Elem,
    liftElem: liftElem,
    NoKey: NoKey,
    Key: Key,
    measuredArray: measuredArray,
    measuredLazy: measuredLazy,
    measuredElem: measuredElem,
    showElem: showElem,
    eqElem: eqElem,
    ordElem: ordElem,
    foldableElem: foldableElem,
    functorElem: functorElem,
    traversableElem: traversableElem,
    eqKey: eqKey,
    showKey: showKey,
    semigroupKey: semigroupKey,
    ordKey: ordKey,
    monoidKey: monoidKey,
    measuredElemKey: measuredElemKey
};
